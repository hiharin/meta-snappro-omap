From a76dcd96d42d7f2d9f0c686d606d884f81a76f8a Mon Sep 17 00:00:00 2001
From: Mohamed Thalib H <mohamed@e-consystems.com>
Date: Mon, 19 May 2014 18:35:02 +0530
Subject: [PATCH 2/8] Patch: IDexx, without nand support Signed-off-by:
 Mohamed Thalib H <mohamed@e-consystems.com>

---
 arch/arm/configs/walnut_defconfig                  |   37 +-
 arch/arm/include/asm/vfpmacros.h                   |    4 +-
 arch/arm/mach-omap2/board-omap3logic-display.c     |   18 +-
 arch/arm/mach-omap2/board-omap3logic.c             |  146 ++-
 arch/arm/mach-omap2/gpmc.c                         |    2 +-
 drivers/input/touchscreen/ft5x06-i2c.c             |   23 +-
 drivers/media/video/v4l2-ioctl.c                   |    6 +
 drivers/mfd/twl4030-power.c                        |  156 +++
 drivers/mfd/twl4030-power.h                        |   24 +
 drivers/mmc/host/omap_hsmmc.c                      |   18 +-
 drivers/net/phy/smsc.c                             |    2 +-
 drivers/rtc/rtc-twl.c                              |   27 +-
 drivers/tty/mcu_comm/idexxmcu.c                    |  264 ++--
 drivers/tty/mcu_comm/proto.c                       |  361 ++++--
 drivers/tty/mcu_comm/proto.h                       |  457 ++++---
 drivers/tty/mcu_comm/workArray.h                   |  171 +--
 .../video/omap2/displays/panel-himax-hx8369a02.c   |  561 +++++++--
 include/linux/idexxmcu_ioctl.h                     | 1271 +++++++++++++-------
 include/media/v4l2-chip-ident.h                    |    1 +
 19 files changed, 2487 insertions(+), 1062 deletions(-)
 create mode 100644 drivers/mfd/twl4030-power.h

diff --git a/arch/arm/configs/walnut_defconfig b/arch/arm/configs/walnut_defconfig
index b23807a..b01269d 100644
--- a/arch/arm/configs/walnut_defconfig
+++ b/arch/arm/configs/walnut_defconfig
@@ -1,5 +1,6 @@
 #
-# Linux/arm 3.1.10 Kernel Configuration for Walnut
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.1.10 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -71,7 +72,8 @@ CONFIG_TINY_RCU=y
 # CONFIG_PREEMPT_RCU is not set
 # CONFIG_RCU_TRACE is not set
 # CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_IKCONFIG is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=16
 # CONFIG_CGROUPS is not set
 # CONFIG_NAMESPACES is not set
@@ -90,7 +92,7 @@ CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 # CONFIG_PRINTK_DEBUG is not set
 # CONFIG_BUG is not set
-# CONFIG_ELF_CORE is not set
+CONFIG_ELF_CORE=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
@@ -748,7 +750,11 @@ CONFIG_MTD_NAND_IDS=y
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_UBI is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
@@ -1009,8 +1015,8 @@ CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_W90X900 is not set
 # CONFIG_TOUCHSCREEN_ST1232 is not set
 # CONFIG_TOUCHSCREEN_TPS6507X is not set
-CONFIG_TOUCHSCREEN_NT11002=m
-# CONFIG_TOUCHSCREEN_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_NT11002 is not set
+CONFIG_TOUCHSCREEN_FT5X06=m
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -1487,8 +1493,8 @@ CONFIG_FB_OMAP2_NUM_FBS=1
 # CONFIG_PANEL_NEC_NL8048HL11_01B is not set
 # CONFIG_PANEL_TPO_TD043MTEA1 is not set
 # CONFIG_PANEL_OMAP3LOGIC is not set
-CONFIG_PANEL_SEIKO_35WVF0HZ2=y
-# CONFIG_PANEL_HIMAX_HX8369A02 is not set
+# CONFIG_PANEL_SEIKO_35WVF0HZ2 is not set
+CONFIG_PANEL_HIMAX_HX8369A02=y
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
 # CONFIG_LCD_CLASS_DEVICE is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
@@ -1717,7 +1723,9 @@ CONFIG_USB_FILE_STORAGE=m
 # CONFIG_USB_G_SERIAL is not set
 # CONFIG_USB_G_PRINTER is not set
 # CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_G_MULTI is not set
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+# CONFIG_USB_G_MULTI_CDC is not set
 # CONFIG_USB_G_HID is not set
 # CONFIG_USB_G_DBGP is not set
 # CONFIG_USB_G_WEBCAM is not set
@@ -1777,7 +1785,8 @@ CONFIG_LEDS_A6281=m
 # CONFIG_ACCESSIBILITY is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
-# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
 # CONFIG_RTC_DEBUG is not set
 
 #
@@ -1806,7 +1815,7 @@ CONFIG_RTC_INTF_DEV=y
 # CONFIG_RTC_DRV_M41T80 is not set
 # CONFIG_RTC_DRV_BQ32K is not set
 # CONFIG_RTC_DRV_TWL92330 is not set
-CONFIG_RTC_DRV_TWL4030=m
+CONFIG_RTC_DRV_TWL4030=y
 # CONFIG_RTC_DRV_S35390A is not set
 # CONFIG_RTC_DRV_FM3130 is not set
 # CONFIG_RTC_DRV_RX8581 is not set
@@ -1936,6 +1945,12 @@ CONFIG_JFFS2_ZLIB=y
 # CONFIG_JFFS2_LZO is not set
 CONFIG_JFFS2_RTIME=y
 # CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=m
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
 # CONFIG_LOGFS is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_SQUASHFS is not set
diff --git a/arch/arm/include/asm/vfpmacros.h b/arch/arm/include/asm/vfpmacros.h
index 3d5fc41..bf53047 100644
--- a/arch/arm/include/asm/vfpmacros.h
+++ b/arch/arm/include/asm/vfpmacros.h
@@ -28,7 +28,7 @@
 	ldr	\tmp, =elf_hwcap		    @ may not have MVFR regs
 	ldr	\tmp, [\tmp, #0]
 	tst	\tmp, #HWCAP_VFPv3D16
-	ldceq	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d16-d31}
+	ldceql	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d16-d31}
 	addne	\base, \base, #32*4		    @ step over unused register space
 #else
 	VFPFMRX	\tmp, MVFR0			    @ Media and VFP Feature Register 0
@@ -52,7 +52,7 @@
 	ldr	\tmp, =elf_hwcap		    @ may not have MVFR regs
 	ldr	\tmp, [\tmp, #0]
 	tst	\tmp, #HWCAP_VFPv3D16
-	stceq	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d16-d31}
+	stceql	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d16-d31}
 	addne	\base, \base, #32*4		    @ step over unused register space
 #else
 	VFPFMRX	\tmp, MVFR0			    @ Media and VFP Feature Register 0
diff --git a/arch/arm/mach-omap2/board-omap3logic-display.c b/arch/arm/mach-omap2/board-omap3logic-display.c
index a082a88..d4904bc 100644
--- a/arch/arm/mach-omap2/board-omap3logic-display.c
+++ b/arch/arm/mach-omap2/board-omap3logic-display.c
@@ -64,6 +64,12 @@ static struct omap3logic_dss_board_info omap3logic_dss_lcd_data = {
 	.gpio_flag = 0,
 };
 
+#if defined(CONFIG_PANEL_SEIKO_35WVF0HZ2) || defined(CONFIG_PANEL_OMAP3LOGIC)
+	#define LCD_RESET_GPIO	131
+#elif defined(CONFIG_PANEL_HIMAX_HX8369A02)
+	#define LCD_RESET_GPIO	153
+#endif
+
 #define MAX_BRIGHTNESS 255
 
 #define MAX_SOM_LV_BRIGHTNESS 127
@@ -470,6 +476,10 @@ static int omap3logic_panel_pre_enable_lcd(struct omap_dss_device *dssdev)
 
 	pdata->lcd_enabled = 1;
 
+#if defined(CONFIG_BACKLIGHT_GENERIC)
+    /* Bring up backlight */
+    omap3logic_enable_backlight();
+#endif
 	return 0;
 }
 
@@ -791,8 +801,14 @@ static void omap3logic_lcd_set_panel_mux(void)
 	} else
 		BUG();
 
-	pdata->lcd_reset = 131;
+	pdata->lcd_reset = LCD_RESET_GPIO;
+
+#if (LCD_RESET_GPIO==131)
 	omap_mux_init_signal("sdmmc2_cmd.gpio_131", OMAP_PIN_OUTPUT);
+#elif(LCD_RESET_GPIO==153)
+	omap_mux_init_signal("mcbsp4_dr.gpio_153", OMAP_PIN_OUTPUT);
+#endif
+
 	if (gpio_request(pdata->lcd_reset, "LCD reset"))
 		pr_err("omap3logic: can't request GPIO %d for LCD reset\n", pdata->lcd_reset);
 
diff --git a/arch/arm/mach-omap2/board-omap3logic.c b/arch/arm/mach-omap2/board-omap3logic.c
index dd030a7..58943d3 100644
--- a/arch/arm/mach-omap2/board-omap3logic.c
+++ b/arch/arm/mach-omap2/board-omap3logic.c
@@ -80,6 +80,8 @@
 #define OMAP3_TORPEDO_MMC_GPIO_CD		127
 #define OMAP3_TORPEDO_SMSC911X_GPIO_IRQ		129
 
+#define SNAPPRO_ALPHA2_BOARD			1
+
 static struct regulator_consumer_supply omap3logic_vmmc1_supply = {
 	.supply			= "vmmc",
 };
@@ -198,7 +200,7 @@ static struct regulator_consumer_supply omap3logic_vaux4_supply = {
 	.supply			= "vaux4",
 };
 
-/* VAUX4 regulator required for ov3640 camera sensor */
+/* VAUX4 regulator required for camera sensor */
 static struct regulator_init_data omap3logic_vaux4 = {
 	.constraints = {
 		.name			= "VAUX4",
@@ -353,16 +355,29 @@ static struct twl4030_platform_data omap3logic_twldata = {
 
 #if defined(CONFIG_TOUCHSCREEN_FT5X06) || defined(CONFIG_TOUCHSCREEN_FT5X06_MODULE)
 #define FT5X06_IRQ_GPIO 	150
+#if defined(SNAPPRO_ALPHA2_BOARD)
+#define FT5X06_RESET_GPIO 	149
+#else
 #define FT5X06_RESET_GPIO 	131
+#endif
 #define FT5X06_I2C_SLAVEADDRESS (0x70 >> 1)
 
 int ft5x06_platform_init(void)
 {
-	return 0;
+	int ret=0;
+	ret = gpio_request(FT5X06_RESET_GPIO, "ft5x06-reset");
+	if (ret < 0) {
+		printk(KERN_WARNING "failed to request GPIO#%d: %d\n",
+				FT5X06_RESET_GPIO, ret);
+		return ret;
+	}
+	gpio_free(FT5X06_RESET_GPIO);
+	return ret;
 }
 
 void ft5x06_platform_exit(void)
 {
+	gpio_free(FT5X06_RESET_GPIO);
 	return;
 }
 
@@ -421,42 +436,42 @@ struct nt11002_platform_data dm3730logic_nt11002data =
 #endif
 
 /*
- * ov3640 is not a platform device, need to pass it enogh data to manage regulator
+ * camera is not a platform device, need to pass it enogh data to manage regulator
  */
-struct regulator	*ov3640_reg;
+struct regulator	*camera_reg;
 /*
- * Regulator control for ov3640 data D0, D1 lines.
+ * Regulator control for camera data D0, D1 lines.
  *
  */
-int ov3640_platform_hook(int on) {
+int camera_platform_hook(int on) {
     	int err=0;
 
-    	if (NULL == ov3640_reg)
-        	ov3640_reg = regulator_get(NULL, "vaux4");
-    	if (IS_ERR(ov3640_reg)) {
+    	if (NULL == camera_reg)
+        	camera_reg = regulator_get(NULL, "vaux4");
+    	if (IS_ERR(camera_reg)) {
         	pr_err("%s: unable to get vaux4 regulator\n", __FUNCTION__);
-        	return PTR_ERR(ov3640_reg);
+        	return PTR_ERR(camera_reg);
     	}
 
     	if ( on ) {
-        	err = regulator_enable(ov3640_reg);
+        	err = regulator_enable(camera_reg);
     	} else {
-        	if (regulator_is_enabled(ov3640_reg))
-        	    	err = regulator_disable(ov3640_reg);
-        	regulator_put(ov3640_reg);
-        	ov3640_reg = NULL;
+        	if (regulator_is_enabled(camera_reg))
+        	    	err = regulator_disable(camera_reg);
+        	regulator_put(camera_reg);
+        	camera_reg = NULL;
     	}
     	return err;
 }
 
-int (*omap3logic_ov3640data)(int) = ov3640_platform_hook;
-#define OV3640_I2C_ADDR		(0x78 >> 1)
+int (*omap3logic_cameradata)(int) = camera_platform_hook;
+#define CAMERA_I2C_ADDR		(0x78 >> 1)
 
 static struct i2c_board_info __initdata omap3logic_i2c2_boardinfo[] = {
 	{
-		I2C_BOARD_INFO("ov3640", OV3640_I2C_ADDR),
-		.type	 	= "ov3640",
-		.platform_data	= &omap3logic_ov3640data,
+		I2C_BOARD_INFO("camera", CAMERA_I2C_ADDR),
+		.type	 	= "camera",
+		.platform_data	= &omap3logic_cameradata,
 	},
 #if defined(CONFIG_TOUCHSCREEN_NT11002) || defined(CONFIG_TOUCHSCREEN_NT11002_MODULE)
 	{
@@ -465,6 +480,7 @@ static struct i2c_board_info __initdata omap3logic_i2c2_boardinfo[] = {
 		.platform_data 	= &dm3730logic_nt11002data,
 	},
 #endif
+#if !defined(SNAPPRO_ALPHA2_BOARD)
 #if defined(CONFIG_TOUCHSCREEN_FT5X06) || defined(CONFIG_TOUCHSCREEN_FT5X06_MODULE)
 	{
 		I2C_BOARD_INFO(FT_I2C_NAME, FT5X06_I2C_SLAVEADDRESS),
@@ -472,27 +488,53 @@ static struct i2c_board_info __initdata omap3logic_i2c2_boardinfo[] = {
 		.platform_data 	= &dm3730logic_ft5x06data,
 	},
 #endif
+#endif
 };
 
+#if defined(SNAPPRO_ALPHA2_BOARD)
+static struct i2c_board_info __initdata omap3logic_i2c3_boardinfo[] = {
+#if defined(CONFIG_TOUCHSCREEN_FT5X06) || defined(CONFIG_TOUCHSCREEN_FT5X06_MODULE)
+	{
+		I2C_BOARD_INFO(FT_I2C_NAME, FT5X06_I2C_SLAVEADDRESS),
+		.type		= FT_I2C_NAME,
+		.platform_data 	= &dm3730logic_ft5x06data,
+	},
+#endif
+};
+#endif
+
 static int __init omap3logic_i2c_init(void)
 {
 
 #if defined(CONFIG_TOUCHSCREEN_NT11002) || defined(CONFIG_TOUCHSCREEN_NT11002_MODULE)
-       omap_mux_init_signal("uart1_cts.gpio_150", OMAP_PIN_INPUT);
+       	omap_mux_init_signal("uart1_cts.gpio_150", OMAP_PIN_INPUT);
+
 
-       omap3logic_i2c2_boardinfo[1].irq = gpio_to_irq(GPIO_NT11002_IRQ);
+       	omap3logic_i2c2_boardinfo[1].irq = gpio_to_irq(GPIO_NT11002_IRQ);
 
 #endif
 
 #if defined(CONFIG_TOUCHSCREEN_FT5X06) || defined(CONFIG_TOUCHSCREEN_FT5X06_MODULE)
+	/* Configure the processor pin for GPIO149 to be used as FT5X06_RESET_GPIO */
+#if defined(SNAPPRO_ALPHA2_BOARD)
+	omap_mux_init_signal("uart1_rts.gpio_149", OMAP_PIN_INPUT);
+#endif
  	omap_mux_init_signal("uart1_cts.gpio_150", OMAP_PIN_INPUT);
 
-	omap3logic_i2c2_boardinfo[1].irq = gpio_to_irq(FT5X06_IRQ_GPIO);
+#if defined(SNAPPRO_ALPHA2_BOARD)
+	omap3logic_i2c3_boardinfo[0].irq = gpio_to_irq(FT5X06_IRQ_GPIO); /* In Alpha2 Board FT5X06 is in i2c3 bus */
+#else
+	omap3logic_i2c2_boardinfo[1].irq = gpio_to_irq(FT5X06_IRQ_GPIO); /* In Alpha Board FT5X06 is in i2c2 bus */
+#endif
 #endif
 
 	omap3_pmic_init("twl4030", &omap3logic_twldata);
 	omap_register_i2c_bus(2, 100, omap3logic_i2c2_boardinfo,
 			ARRAY_SIZE(omap3logic_i2c2_boardinfo));
+#if defined(SNAPPRO_ALPHA2_BOARD)
+	omap_register_i2c_bus(3, 400, omap3logic_i2c3_boardinfo,	/* i2c3 bus registration for FT5X06 touchscreen device */
+			ARRAY_SIZE(omap3logic_i2c3_boardinfo));
+#endif
 	return 0;
 }
 
@@ -875,7 +917,8 @@ static void omap3logic_spi_init(void)
 
 #if defined(CONFIG_USB_ISP1763) || defined(CONFIG_USB_ISP1763_MODULE)
 /* ISP1763 USB interrupt */
-#define OMAP3TORPEDO_ISP1763_IRQ_GPIO          128
+#define OMAP3TORPEDO_ISP1763_IRQ_GPIO          	128
+#define ISP1763_RESET				171
 
 static struct isp1763_platform_data omap3logic_isp1763_pdata = {
        .bus_width_8            = 0,
@@ -906,7 +949,6 @@ static struct platform_device omap3logic_isp1763 = {
        .resource = omap3logic_isp1763_resources,
 };
 
-#define ISP1763_PWR_EN      135
 
 static int omap3logic_init_isp1763(void)
 {
@@ -940,10 +982,12 @@ static int omap3logic_init_isp1763(void)
        gpio_direction_input(irq_gpio);
        omap3logic_isp1763_resources[1].start = OMAP_GPIO_IRQ(irq_gpio);
 
-        /* Enable USB power by driving GPIO 135 high */
-        omap_mux_init_signal("sdmmc2_dat3.gpio_135", OMAP_PIN_OUTPUT);
-        gpio_request(ISP1763_PWR_EN, "isp1763_pwr_en");
-	    gpio_direction_output(ISP1763_PWR_EN, 1);
+       omap_mux_init_signal("mcspi1_clk.gpio_171", OMAP_PIN_OUTPUT);
+       gpio_request(ISP1763_RESET, "isp1763_RESET");
+       gpio_direction_output(ISP1763_RESET, 1);
+       gpio_set_value(ISP1763_RESET, 0);
+       gpio_set_value(ISP1763_RESET, 1);
+
 
        if (platform_device_register(&omap3logic_isp1763) < 0) {
                printk(KERN_ERR "Unable to register isp1763 device\n");
@@ -1221,8 +1265,19 @@ static void walnut_init_mcu(void)
 	#define UP_MCU_RESET_ALPHA_PIN		134
 	#define UP_MCU_RESET_MCU_BOARD_PIN	143
 	#define UP_MCU_BOOTLOADER_PIN		141
-	#define UP_MCU_PWRDN			142
+	#define UP_MCU_PWRDN			21 //142
 	#define USB_MOSFET			172
+	#define UP_UART3_CTS			163
+	#define UP_UART3_RTS			164
+
+	/* Configure the mux to use uart3_cts_rctx as GPIO163 */
+	omap_mux_init_signal("uart3_cts_rctx.gpio_163", OMAP_PIN_OUTPUT);
+
+	/* Configure the mux to use uart3_rts_sd as GPIO164 */
+	omap_mux_init_signal("uart3_rts_sd.gpio_164", OMAP_PIN_OUTPUT);
+
+
+
 
 	// MCU_nINT
 	omap_mux_init_signal("mcbsp3_dx.gpio_140", OMAP_PIN_INPUT);
@@ -1246,10 +1301,14 @@ static void walnut_init_mcu(void)
 	omap_mux_init_signal("mcbsp3_dr.gpio_141", OMAP_PIN_INPUT);
 
 	//up_MCU_PWRDN
+#if (UP_MCU_PWRDN==142)
 	omap_mux_init_signal("mcbsp3_clkx.gpio_142", OMAP_PIN_INPUT);
+#elif (UP_MCU_PWRDN==21)
+	omap_mux_init_signal("etk_d7.gpio_21", OMAP_PIN_INPUT);
+#endif
 
 	//USB-OTG Event Monitor
-	omap_mux_init_signal("uart2_rts.gpio_145", OMAP_PIN_INPUT);
+	//omap_mux_init_signal("uart2_rts.gpio_145", OMAP_PIN_INPUT); /* GPIO145 should not be configured when using uart2_rts for bluetooth */
 	
 	// Initialize the MCU pin to be in a non reset state
 	gpio_request(UP_MCU_PWRDN, "UP_MCU_PWRDWN");
@@ -1258,6 +1317,13 @@ static void walnut_init_mcu(void)
 	gpio_request(UP_MCU_RESET_ALPHA_PIN, "UP_MCU_RESET_ALPHA");
 	gpio_request(UP_MCU_RESET_ALPHA_REWORK_PIN, "UP_MCU_RESET_ALPHA_REWORK");
 	gpio_request(UP_MCU_BOOTLOADER_PIN, "UP_MCU_BOOTLOADER");
+	gpio_request(UP_UART3_CTS, "UP_UART3_CTS");
+	gpio_request(UP_UART3_RTS, "UP_UART3_RTS");
+
+	/* Configure GPIO163 as GPIO OUTPUT and Drive 1 */
+	gpio_direction_output(UP_UART3_CTS, 1);
+	/* Configure GPIO164 as GPIO OUTPUT and Drive 1 */
+	gpio_direction_output(UP_UART3_RTS, 1);
 
 	gpio_direction_output(UP_MCU_PWRDN, 1);
 	gpio_direction_output(USB_MOSFET, 1);
@@ -1266,6 +1332,12 @@ static void walnut_init_mcu(void)
 	gpio_set_value(UP_MCU_RESET_ALPHA_REWORK_PIN, 0);
 	gpio_set_value(UP_MCU_BOOTLOADER_PIN, 0);
 
+	/* Drive 0 on GPIO163 */
+	gpio_set_value(UP_UART3_CTS,0);
+	/* Drive 0 on GPIO164 */
+	gpio_set_value(UP_UART3_RTS,0);
+
+
 	gpio_free(UP_MCU_PWRDN);
 	gpio_free(UP_MCU_BOOTLOADER_PIN);
 
@@ -1273,6 +1345,11 @@ static void walnut_init_mcu(void)
 	gpio_export(USB_MOSFET, 1);
 	gpio_export(UP_MCU_RESET_ALPHA_PIN, 1);
 	gpio_export(UP_MCU_RESET_ALPHA_REWORK_PIN, 1);
+	/* Export GPIO163 to sysfs */
+	gpio_export(UP_UART3_CTS,1);
+	/* Export GPIO164 to sysfs */
+	gpio_export(UP_UART3_RTS,1);
+
 }
 
 static void __init omap3logic_init(void)
@@ -1293,7 +1370,7 @@ static void __init omap3logic_init(void)
 
 #ifdef CONFIG_OMAP3LOGIC_UART_A
 	omap_mux_init_signal("uart1_tx.uart1_tx", OMAP_PIN_OUTPUT);
-	omap_mux_init_signal("uart1_rts.uart1_rts", OMAP_PIN_OUTPUT);
+	//omap_mux_init_signal("uart1_rts.uart1_rts", OMAP_PIN_OUTPUT);
 	omap_mux_init_signal("uart1_cts.uart1_cts", OMAP_PIN_INPUT);
 	omap_mux_init_signal("uart1_rx.uart1_rx", OMAP_PIN_INPUT);
 
@@ -1321,8 +1398,8 @@ static void __init omap3logic_init(void)
 
 #ifdef CONFIG_OMAP3LOGIC_UART_C
 	omap_mux_init_signal("uart3_tx_irtx.uart3_tx_irtx", OMAP_PIN_OUTPUT);
-	omap_mux_init_signal("uart3_rts_sd.uart3_rts_sd", OMAP_PIN_OUTPUT);
-	omap_mux_init_signal("uart3_cts_rctx.uart3_cts_rctx", OMAP_PIN_INPUT);
+	//omap_mux_init_signal("uart3_rts_sd.uart3_rts_sd", OMAP_PIN_OUTPUT); /* This uart3_rts_sd is used as GPIO164 */
+	//omap_mux_init_signal("uart3_cts_rctx.uart3_cts_rctx", OMAP_PIN_INPUT); /* This uart3_cts_rctx is ised as GPIO163 */
 	omap_mux_init_signal("uart3_rx_irrx.uart3_rx_irrx", OMAP_PIN_INPUT);
 
 	// Taken from serial.c:omap_serial_init()
@@ -1332,6 +1409,7 @@ static void __init omap3logic_init(void)
 	bdata.pads_cnt = 0;
 	omap_serial_init_port(&bdata);
 #endif
+	
 
 	omap3logic_i2c_init();
 	omap3logic_lcd_init();
diff --git a/arch/arm/mach-omap2/gpmc.c b/arch/arm/mach-omap2/gpmc.c
index f2f3c27..22f769d 100644
--- a/arch/arm/mach-omap2/gpmc.c
+++ b/arch/arm/mach-omap2/gpmc.c
@@ -103,7 +103,7 @@ static struct clk *gpmc_l3_clk;
 
 static irqreturn_t gpmc_handle_irq(int irq, void *dev);
 
-static void gpmc_write_reg(int idx, u32 val)
+void gpmc_write_reg(int idx, u32 val)
 {
 	__raw_writel(val, gpmc_base + idx);
 }
diff --git a/drivers/input/touchscreen/ft5x06-i2c.c b/drivers/input/touchscreen/ft5x06-i2c.c
index 9e2b841..4c03c82 100644
--- a/drivers/input/touchscreen/ft5x06-i2c.c
+++ b/drivers/input/touchscreen/ft5x06-i2c.c
@@ -622,13 +622,14 @@ static void ft5x06_reset_panel_via_gpio(int reset_gpio)
 #endif				/* FT5x06_DEBUG_VERBOSE */
 
 // Uncomment these when the Touch and LCD reset lines are separated
-/*    gpio_direction_output(reset_gpio, 1);
+
+    gpio_direction_output(reset_gpio, 1);
     msleep(20);
     gpio_direction_output(reset_gpio, 0);
     msleep(20);
     gpio_direction_output(reset_gpio, 1);
     msleep(300);
-*/
+
 }
 
 static bool ft5x06_poll_gpio(const int gpio_num,
@@ -2924,7 +2925,7 @@ static int ft5x06_suspend(struct i2c_client *client, pm_message_t message)
 
     // keep focaltech controller in reset after this point
     // Uncomment the following section when the touch/LCD reset lines are separated
-//      gpio_direction_output(ts->platform_data->reset_gpio, 0);
+      gpio_direction_output(ts->platform_data->reset_gpio, 0);
 
     return 0;
 }
@@ -2952,11 +2953,6 @@ static int __devexit ft5x06_remove(struct i2c_client *client)
 	       __FUNCTION__);
     }
 
-    /* free up timer or irq */
-    if (ts->client->irq == 0) {
-    } else {
-	free_irq(client->irq, ts);
-    }
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
     unregister_early_suspend(&ts->early_suspend);
@@ -2972,6 +2968,17 @@ static int __devexit ft5x06_remove(struct i2c_client *client)
     mutex_unlock(&ts->device_mode_mutex);
     mutex_destroy(&ts->device_mode_mutex);
 
+
+    /* free up timer or irq */
+    if (ts->client->irq == 0) {
+    } else {
+	free_irq(client->irq, ts);
+    }
+
+    //Unregister the input device registered
+    printk(KERN_INFO "%s() - Unregister the input device registered \n",__FUNCTION__);
+    input_unregister_device(ts->input);
+
     if (NULL != ts) {
 	kfree(ts);
     }
diff --git a/drivers/media/video/v4l2-ioctl.c b/drivers/media/video/v4l2-ioctl.c
index 002ce13..da87bf0 100644
--- a/drivers/media/video/v4l2-ioctl.c
+++ b/drivers/media/video/v4l2-ioctl.c
@@ -2354,6 +2354,12 @@ video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
 			if (copy_from_user(parg, (void __user *)arg, n))
 				goto out;
 
+            		if (cmd == VIDIOC_G_CTRL
+			    && ((struct v4l2_control *) parg)->id == V4L2_CID_PRIVATE_BASE) {
+		  		n = _IOC_SIZE(cmd);
+				if (copy_from_user(parg, (void __user *)arg, n))
+					goto out;
+            		}
 			/* zero out anything we don't copy from userspace */
 			if (n < _IOC_SIZE(cmd))
 				memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);
diff --git a/drivers/mfd/twl4030-power.c b/drivers/mfd/twl4030-power.c
index d905f51..be5ad25 100644
--- a/drivers/mfd/twl4030-power.c
+++ b/drivers/mfd/twl4030-power.c
@@ -30,6 +30,10 @@
 #include <linux/platform_device.h>
 
 #include <asm/mach-types.h>
+#include <asm/delay.h>
+#if CONFIG_TWL4030_WALNUT
+#include "twl4030-power.h"
+#endif
 
 static u8 twl4030_start_script_address = 0x2b;
 
@@ -527,6 +531,149 @@ void twl4030_power_off(void)
 		pr_err("TWL4030 Unable to power off\n");
 }
 
+
+#if CONFIG_TWL4030_WALNUT
+/*
+ * Routine: config_pmic_registers
+ * Description: Configure the PMIC registers to disable starting on
+ * VBAT and VBUS
+ */
+void config_pmic_registers(void)
+{
+	u8 val = 0;
+	int ret = 0;
+	u8 valCfg = 0;
+
+	/* Unset start on VBAT, VBUS and CFG if set*/
+	ret = twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+				  TWL4030_PM_MASTER_CFG_P1_TRANSITION);
+	if (ret) {
+		udelay(100);
+		printk("%s - retrying read of TWL4030_MODULE_PM_MASTER rc:%d val:%d\n",
+		       __FUNCTION__, twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+							 TWL4030_PM_MASTER_CFG_P1_TRANSITION),
+		       val);
+	}
+
+	/* Set CK23K_LOWPWR_EN in CFG_BOOT */
+	ret = twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &valCfg,
+				  TWL4030_PM_MASTER_CFG_BOOT);
+
+	if (
+		(val != (TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_SWBUG |
+			 TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_PWON)) ||
+		(0 == (valCfg & (1<<7)))
+		){
+		/* Enable access to the power registers:
+		 * Write 0xC0, followed by 0x0C.
+		 * Read back 10 for power config reg access, and
+		 * 11 for power config and test reg access.*/
+		val = 0xC0;
+		twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+				     TWL4030_PM_MASTER_PROTECT_KEY);
+		val = 0x0C;
+		twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+				     TWL4030_PM_MASTER_PROTECT_KEY);
+
+		twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+				    TWL4030_PM_MASTER_PROTECT_KEY);
+		if (val == 0x2 || val == 0x3)
+		{
+			/* Unset wake on VBAT , VBUS and CHG */
+			if (val != (TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_SWBUG |
+				    TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_PWON)) {
+				val = (TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_SWBUG |
+				       TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_PWON);
+
+				ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+							   TWL4030_PM_MASTER_CFG_P1_TRANSITION);
+				ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+							   TWL4030_PM_MASTER_CFG_P2_TRANSITION);
+				ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+							   TWL4030_PM_MASTER_CFG_P3_TRANSITION);
+			}
+			/* Set CK23K_LOWPWR_EN in CFG_BOOT */
+			if ( 0 == (valCfg & (1<<7))) {
+				valCfg |= (1<<7);
+				ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, valCfg,
+							   TWL4030_PM_MASTER_CFG_BOOT);
+			}
+		} else
+			printk("Unable to get access to power reg: 0x%x\n", val);
+
+		/* Disable access to the power registers */
+		val = 0xAB;
+		twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+				     TWL4030_PM_MASTER_PROTECT_KEY);
+	}
+
+	/* Setup the power button to turn us on */
+	ret = twl_i2c_read_u8(TWL4030_MODULE_INT, &val,
+				  TWL4030_PM_INT_PWR_SIH_CTRL);
+
+	if (!(val & (1 << 2))) {
+		// Enable COR
+		val |= (1 << 2);
+
+		ret = twl_i2c_write_u8(TWL4030_MODULE_INT, val,
+					   TWL4030_PM_INT_PWR_SIH_CTRL);
+	}
+	/* Clear any pending Power button IRQs */
+	ret = twl_i2c_read_u8(TWL4030_MODULE_INT, &val,
+				  TWL4030_PM_INT_PWR_ISR1);
+	ret = twl_i2c_read_u8(TWL4030_MODULE_INT, &val,
+				  TWL4030_PM_INT_PWR_ISR2);
+	ret = twl_i2c_read_u8(TWL4030_MODULE_INT, &val,
+				  TWL4030_PM_INT_PWR_ISR1);
+	ret = twl_i2c_read_u8(TWL4030_MODULE_INT, &val,
+				  TWL4030_PM_INT_PWR_ISR2);
+
+	ret = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &val,
+				  TWL4030_PM_RECEIVER_IT_CHECK_CFG);
+
+	if (ret) {
+		printk("%s - retrying read of TWL4030_MODULE_PM_RECEIVER\n",__FUNCTION__);
+		udelay(100);
+		ret = twl_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &val,
+					  TWL4030_PM_RECEIVER_IT_CHECK_CFG);
+	}
+	val &= ~(1 << 0);
+	val |= (0 << 0); 	//216 ORG	val |= (1 << 0);
+
+	ret = twl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, val,
+				   TWL4030_PM_RECEIVER_IT_CHECK_CFG);
+
+	/* BOOT_BCI */
+	ret = twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+				  TWL4030_PM_MASTER_BOOT_BCI);
+	if (ret) {
+		printk("%s - retrying read of TWL4030_MODULE_PM_MASTER_BOOT_BCI\n",__FUNCTION__);
+		udelay(100);
+		ret = twl_i2c_read_u8(TWL4030_MODULE_PM_MASTER, &val,
+					  TWL4030_PM_MASTER_BOOT_BCI);
+	}
+	if ((val & (1 << 4)) == 0) {
+		val |= (1 << 4);		\
+		val &= ~(1 << 0);
+
+		ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+					   TWL4030_PM_MASTER_BOOT_BCI);
+	}
+
+	if (val & (1 << 5)) {
+		// Unset BCIAUTOAC
+		val &= ~(1 << 0);
+		// Unset BCICVACEN
+		val &= ~(1 << 2);
+
+		ret = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, val,
+					   TWL4030_PM_MASTER_BOOT_BCI);
+	}
+}
+#endif
+
+
+
 void __init twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
 {
 	int err = 0;
@@ -534,6 +681,15 @@ void __init twl4030_power_init(struct twl4030_power_data *twl4030_scripts)
 	struct twl4030_resconfig *resconfig;
 	u8 val, address = twl4030_start_script_address;
 
+
+#if CONFIG_TWL4030_WALNUT
+	/* Configuring PMIC registers as it would be done in u-boot.
+	 As it is not done in xboot, the PMIC configuration is done here.
+         To keep the xboot size witin 50K and avoid delay in xboot booting 
+        pmic configuration is not done in xboot */
+	config_pmic_registers();
+#endif
+
 	err = twl_i2c_write_u8(TWL4030_MODULE_PM_MASTER,
 			TWL4030_PM_MASTER_KEY_CFG1,
 			TWL4030_PM_MASTER_PROTECT_KEY);
diff --git a/drivers/mfd/twl4030-power.h b/drivers/mfd/twl4030-power.h
new file mode 100644
index 0000000..b0e34dc
--- /dev/null
+++ b/drivers/mfd/twl4030-power.h
@@ -0,0 +1,24 @@
+/*
+ * linux/drivers/i2c/chips/twl4030-power.h
+ *
+ * Handle TWL4030 Power initialization
+ *
+ * Taken from u-boot/ti/logic/logic.c source file
+ * 
+ */
+
+/* CFG_P[1-3]_TRANSITION */
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_SWBUG	(1 << 7)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_VBUS	(1 << 5)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_VBAT	(1 << 4)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_RTC	(1 << 3)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_USB	(1 << 2)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_CHG	(1 << 1)
+#define TWL4030_PM_MASTER_CFG_TRANSITION_STARTON_PWON	(1 << 0)
+
+#define TWL4030_PM_INT_PWR_ISR1 			0x2E
+#define TWL4030_PM_INT_PWR_ISR2 			0x30
+#define TWL4030_PM_INT_PWR_SIH_CTRL 			0x35
+
+#define TWL4030_PM_RECEIVER_IT_CHECK_CFG		0x5F
+
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 19b6067..0e4c41b 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -450,15 +450,15 @@ static int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)
 		* framework is fixed, we need a workaround like this
 		* (which is safe for MMC, but not in general).
 		*/
-		if (regulator_is_enabled(host->vcc) > 0) {
-			regulator_enable(host->vcc);
-			regulator_disable(host->vcc);
-		}
-		if (host->vcc_aux) {
-			if (regulator_is_enabled(reg) > 0) {
-				regulator_enable(reg);
-				regulator_disable(reg);
-			}
+
+		if (regulator_is_enabled(host->vcc) > 0 ||
+		    (host->vcc_aux && regulator_is_enabled(host->vcc_aux))) {
+			int vdd = ffs(mmc_slot(host).ocr_mask) - 1;
+
+			mmc_slot(host).set_power(host->dev, host->slot_id,
+						 1, vdd);
+			mmc_slot(host).set_power(host->dev, host->slot_id,
+						 0, 0);
 		}
 	}
 
diff --git a/drivers/net/phy/smsc.c b/drivers/net/phy/smsc.c
index 342505c..29f6af7 100644
--- a/drivers/net/phy/smsc.c
+++ b/drivers/net/phy/smsc.c
@@ -68,7 +68,7 @@ static int smsc_phy_config_init(struct phy_device *phydev)
 
 	/* Enable energy detect mode for this SMSC Transceivers */
 	rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
-		       rc | MII_LAN83C185_EDPWRDOWN);
+		       rc );//| MII_LAN83C185_EDPWRDOWN);
 	if (rc < 0)
 		return rc;
 
diff --git a/drivers/rtc/rtc-twl.c b/drivers/rtc/rtc-twl.c
index 0d2118f..00b42a1 100644
--- a/drivers/rtc/rtc-twl.c
+++ b/drivers/rtc/rtc-twl.c
@@ -333,9 +333,30 @@ static int twl_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	if (ret < 0)
 		goto out;
 
-	/* update all the time registers in one shot */
-	ret = twl_i2c_write(TWL_MODULE_RTC, rtc_data,
-		(rtc_reg_map[REG_SECONDS_REG]), ALL_TIME_REGS);
+       /* If the RTC is in 12-hour mode, then adjust for it */
+
+       if (save_control & BIT_RTC_CTRL_REG_MODE_12_24_M)
+              rtc_data[3] = twl_rtc_convert_to_12h(tm->tm_hour);
+       else
+              rtc_data[3] = bin2bcd(tm->tm_hour);
+
+       /* update all the time registers in one shot */
+#ifdef RTC_USE_SINGLE_WORD_RW
+        ret = twl_rtc_write_u8(rtc_data[1], rtc_reg_map[REG_SECONDS_REG]);
+        if (ret >= 0)
+                ret = twl_rtc_write_u8(rtc_data[2], rtc_reg_map[REG_MINUTES_REG]);
+        if (ret >= 0)
+                ret = twl_rtc_write_u8(rtc_data[3], rtc_reg_map[REG_HOURS_REG]);
+        if (ret >= 0)
+                ret = twl_rtc_write_u8(rtc_data[4], rtc_reg_map[REG_DAYS_REG]);
+        if (ret >= 0)
+                ret = twl_rtc_write_u8(rtc_data[5], rtc_reg_map[REG_MONTHS_REG]);
+        if (ret >= 0)
+                ret = twl_rtc_write_u8(rtc_data[6], rtc_reg_map[REG_YEARS_REG]);
+#else
+       ret = twl_i2c_write(TWL_MODULE_RTC, rtc_data,
+              (rtc_reg_map[REG_SECONDS_REG]), ALL_TIME_REGS);
+#endif
 	if (ret < 0) {
 		dev_err(dev, "rtc_set_time error %d\n", ret);
 		goto out;
diff --git a/drivers/tty/mcu_comm/idexxmcu.c b/drivers/tty/mcu_comm/idexxmcu.c
index 8005322..889b66a 100644
--- a/drivers/tty/mcu_comm/idexxmcu.c
+++ b/drivers/tty/mcu_comm/idexxmcu.c
@@ -9,7 +9,6 @@
  *
  */
 
-//#include <asm/system.h>
 #include <asm/uaccess.h>
 #include <linux/bitops.h>
 #include <linux/sched.h>
@@ -30,43 +29,38 @@
 #include <linux/moduleparam.h>
 #include <linux/timer.h>
 #include <linux/workqueue.h>
-#include <linux/idexxmcu_ioctl.h>
 
+#include <linux/idexxmcu_ioctl.h>
 #include "workArray.h"
 #include "proto.h"
 
-// move this stuff to a header file.
-#define IDXXMCU_PROTOCOL_VERSION    "0.2.1-c"
+// move this stuff to a header file. AK -- No, please don't. Having it here allows for file (both .c and .h) version cross-check done in idexxmcu_init().
+#define IDXXMCU_PROTOCOL_VERSION    "0.2.1-m"
 #define IDXXMCU_PROTOCOL_NAME       "n_idxmcu"
 
-/*
-static int idexxmcu_maxdev = IDXXMCU_PROTOCOL_NRUINT;
-module_param( idexxmcu_maxdev, int, 0 );
-MODULE_PARM_DESC( idexxmcu_maxdev, "Maximum number of idexxmcu protocol channels." );
- */
-//extern volatile WorkElement SOM_MCU_workRequest[NUMBER_OF_SOM_IOCTLS];
+extern const char idexxmcu_proto_c_version[];
 
 static int idexxmcu_ioctl(struct tty_struct* tty, struct file* file, unsigned int cmd, unsigned long arg);
 
 /* Define the line discipline structure for the mcu communication protocol. */
 static struct tty_ldisc_ops idexxmcu_ldisc ={
-     .magic = TTY_LDISC_MAGIC,
-     .name = IDXXMCU_PROTOCOL_NAME,
-     .open = SOM_MCU_open,
-     .close = SOM_MCU_close,
+	.magic = TTY_LDISC_MAGIC,
+	.name = IDXXMCU_PROTOCOL_NAME,
+	.open = SOM_MCU_open,
+	.close = SOM_MCU_close,
 	.flush_buffer = NULL,
 	.chars_in_buffer = NULL,
-     .read = NULL,
-     .write = NULL,
-     .ioctl = idexxmcu_ioctl,
-     .compat_ioctl = NULL,
-     .set_termios = NULL,
-     .poll = NULL,
-     .hangup = SOM_MCU_hangup,
-     .receive_buf = SOM_MCU_receive_buf,
-     .write_wakeup = SOM_MCU_write_wakeup,
-     .dcd_change = NULL,
-     .owner = THIS_MODULE,
+	.read = NULL,
+	.write = NULL,
+	.ioctl = idexxmcu_ioctl,
+	.compat_ioctl = NULL,
+	.set_termios = NULL,
+	.poll = NULL,
+	.hangup = SOM_MCU_hangup,
+	.receive_buf = SOM_MCU_receive_buf,
+	.write_wakeup = SOM_MCU_write_wakeup,
+	.dcd_change = NULL,
+	.owner = THIS_MODULE,
 };
 
 static int __init idexxmcu_init(void)
@@ -74,12 +68,22 @@ static int __init idexxmcu_init(void)
     int status;
 
     /* Announce the start of our initialization. */
-    printk(KERN_INFO "IDEXX MCU Comminucation Protocol: version %s \n", IDXXMCU_PROTOCOL_VERSION);
+    printk(KERN_INFO "IDEXX MCU Communication Protocol: version %s \n", IDXXMCU_PROTOCOL_VERSION);
     printk(KERN_INFO "Copyright 2012 IDEXX Laboratories, Inc.\n");
 
-    status = tty_register_ldisc(N_IDXMCU, &idexxmcu_ldisc);
-    if (status != 0)
-        printk(KERN_ERR "IDEXXMCU: can't register line discipline (err = %d).\n", status);
+    if (strcmp(IDXXMCU_PROTOCOL_VERSION, idexxmcu_ioctl_h_version) || strcmp(IDXXMCU_PROTOCOL_VERSION, idexxmcu_proto_h_version)
+	          || strcmp(IDXXMCU_PROTOCOL_VERSION, idexxmcu_proto_c_version) || strcmp(IDXXMCU_PROTOCOL_VERSION, idexxmcu_workarray_h_version))
+    {
+		status = 1;
+		printk(KERN_ERR "IDEXXMCU: failed version cross-check.\n");
+    }
+    else
+    {
+          status = tty_register_ldisc(N_IDXMCU, &idexxmcu_ldisc);
+          if (status != 0)
+	          printk(KERN_ERR "IDEXXMCU: can't register line discipline (err = %d).\n", status);
+    }
+
     return status;
 }
 
@@ -90,9 +94,9 @@ static void __exit idexxmcu_exit(void)
     /* Unregister the line discipline. */
     i = tty_unregister_ldisc(N_IDXMCU);
     if (i != 0)
-        printk(KERN_ERR "IDEXXMCU: can't unregister line discipline (err = %d).\n", i);
+	   printk(KERN_ERR "IDEXXMCU: can't unregister line discipline (err = %d).\n", i);
     else
-        printk(KERN_INFO "IDEXXMCU: line discipline unregistered.\n");
+	   printk(KERN_INFO "IDEXXMCU: line discipline unregistered.\n");
 }
 
 module_init(idexxmcu_init);
@@ -106,89 +110,117 @@ MODULE_AUTHOR("Dr. Kouakou E. Diby, David West, Alexander Krigsfeld");
 /* Perform I/O control on an active IDEXXMCU channel. */
 static int idexxmcu_ioctl(struct tty_struct* tty, struct file* file, unsigned int cmd, unsigned long arg)
 {
-     idexxmcu_message_t *myMsg = (idexxmcu_message_t *) arg;
-     SOM_ioctl_cmd real_cmd = (SOM_ioctl_cmd)_IOC_NR(cmd);
-     int retVal;
-     int outSize = 0;
-
-     if (_IOC_TYPE(cmd) != IDEXXMCU_PROTO_MAGIC || real_cmd >= NUMBER_OF_SOM_IOCTLS)
-     {
-          printk(KERN_NOTICE "IDEXXMCU: out of range ioctl command.\n");
-          return -EINVAL;          // 22
-     }
-
-     if (ioctlDefinition[real_cmd].cmdLen && !access_ok(VERIFY_READ, arg, ioctlDefinition[real_cmd].cmdLen))
-     {
-          printk(KERN_NOTICE "IDEXXMCU: ioctl invalid input pointer.\n");
-          return -EFAULT;          // 14
-     }
-
-     if (ioctlDefinition[real_cmd].rspLen)
-     {
-          outSize = ioctlDefinition[real_cmd].rspLen == 0xFE ? MAX_NOTIFICATION_SIZE : ioctlDefinition[real_cmd].rspLen;
-
-          if (!access_ok(VERIFY_WRITE, arg, outSize))
-          {
-               printk(KERN_NOTICE "IDEXXMCU: ioctl invalid output pointer.\n");
-               return -EFAULT;     // 14
-          }
-
-          if (real_cmd == MOTOR_CMD_ACCEPT_PROFILE)
-          {
-               MotorCurProfile temp;
-               copy_from_user(&temp, arg, sizeof(temp));
-               outSize = temp.bufSize;
-               if (!access_ok(VERIFY_WRITE, arg, outSize))
-               {
-                    printk(KERN_NOTICE "IDEXXMCU: ioctl invalid output pointer.\n");
-                    return -EFAULT;     // 14
-               }
-          }
-     }
-
-     if (atomic_cmpxchg(&SOM_MCU_workRequest[real_cmd].onlyOneThread, 0, 1))
-     {
-          printk(KERN_WARNING "IDEXXMCU: ioctl multi-threading attempted.\n");
-          return -EBUSY;           // 16
-     }
-
-     if (ioctlDefinition[real_cmd].cmdLen)
-          SOM_MCU_workRequest[real_cmd].input = (void *)arg;
-     if (outSize)
-     {
-          SOM_MCU_workRequest[real_cmd].output = (void *)arg;
-          SOM_MCU_workRequest[real_cmd].outSize = outSize;
-     }
-
-     SOM_MCU_SubmitToProto(real_cmd); 
-
-     switch (SOM_MCU_workRequest[real_cmd].retValue)
-     {
-          case RESULT_SUCCESS:
-               retVal = 0;
-               break;
-
-          case RESULT_NO_ACK:
-               retVal = -ECONNREFUSED;  // 111
-               break;
-
-          case RESULT_TIMEOUT:
-               retVal = -ETIMEDOUT;     // 110
-               break;
-
-          case RESULT_ABORTED:
-               retVal = -EIO;           // 5
-               break;
-
-          case RESULT_NO_MEM:
-               retVal = -ENOMEM;        // 12
-               break;
-
-          default:
-               retVal = -ENODATA;       // 61
-               break;
-     }
-
-     atomic_set(&SOM_MCU_workRequest[real_cmd].onlyOneThread, 0);
-     return retVal;
+	idexxmcu_message_t *myMsg = (idexxmcu_message_t *) arg;
+	SOM_ioctl_cmd real_cmd = (SOM_ioctl_cmd)_IOC_NR(cmd);
+	int retVal;
+	int outSize = 0;
+	u8 inSize;     // must be 1 byte long
+
+	if (_IOC_TYPE(cmd) != IDEXXMCU_PROTO_MAGIC || real_cmd >= NUMBER_OF_SOM_IOCTLS)
+	{
+		printk(KERN_NOTICE "IDEXXMCU: out of range ioctl command.\n");
+		return -EINVAL;          // 22
+	}
+
+	if (ioctlDefinition[real_cmd].msgType == 0xFF)
+	{
+		printk(KERN_NOTICE "IDEXXMCU: unimplemented ioctl command.\n");
+		return -ENOSYS;          // 38
+	}
+
+     // verify access to the input structure
+     // for variable length data, the first byte is the size of the rest
+     inSize = ioctlDefinition[real_cmd].cmdLen == 0xFE ? sizeof(inSize) : ioctlDefinition[real_cmd].cmdLen;
+	if (inSize)
+	{
+	     if (!access_ok(VERIFY_READ, arg, inSize))
+	     {
+		     printk(KERN_NOTICE "IDEXXMCU: ioctl invalid input pointer.\n");
+		     return -EFAULT;          // 14
+	     }
+
+          if (ioctlDefinition[real_cmd].cmdLen == 0xFE)
+	     {
+		     copy_from_user(&inSize, arg++, sizeof(inSize));
+	          if (inSize && !access_ok(VERIFY_READ, arg, inSize))
+	          {
+		          printk(KERN_NOTICE "IDEXXMCU: ioctl invalid input pointer.\n");
+		          return -EFAULT;          // 14
+	          }
+	     }
+	}
+
+     // verify access to the output structure
+	if (ioctlDefinition[real_cmd].rspLen)
+	{
+		outSize = ioctlDefinition[real_cmd].rspLen == 0xFE ? MAX_NOTIFICATION_SIZE : ioctlDefinition[real_cmd].rspLen;
+
+		if (!access_ok(VERIFY_WRITE, arg, outSize))
+		{
+			printk(KERN_NOTICE "IDEXXMCU: ioctl invalid output pointer.\n");
+			return -EFAULT;     // 14
+		}
+
+		if (real_cmd == MOTOR_CMD_ACCEPT_PROFILE)
+		{
+			MotorCurProfile temp;
+			copy_from_user(&temp, arg, sizeof(temp));
+			outSize = temp.bufSize;
+			if (!access_ok(VERIFY_WRITE, arg, outSize))
+			{
+				printk(KERN_NOTICE "IDEXXMCU: ioctl invalid output pointer.\n");
+				return -EFAULT;     // 14
+			}
+		}
+	}
+
+	if (atomic_cmpxchg(&SOM_MCU_workRequest[real_cmd].onlyOneThread, 0, 1))
+	{
+		printk(KERN_WARNING "IDEXXMCU: ioctl multi-threading attempted.\n");
+		return -EBUSY;           // 16
+	}
+
+	if (SOM_MCU_workRequest[real_cmd].inSize = inSize)
+		SOM_MCU_workRequest[real_cmd].input = (void *)arg;
+	if (outSize)
+	{
+		SOM_MCU_workRequest[real_cmd].output = (void *)arg;
+		SOM_MCU_workRequest[real_cmd].outSize = outSize;
+	}
+
+	SOM_MCU_SubmitToProto(real_cmd);
+
+	switch (SOM_MCU_workRequest[real_cmd].retValue)
+	{
+		case RESULT_SUCCESS:
+			retVal = 0;
+			break;
+
+		case RESULT_NO_ACK:
+			retVal = -ECONNREFUSED;  // 111
+			break;
+
+		case RESULT_TIMEOUT:
+			retVal = -ETIMEDOUT;     // 110
+			break;
+
+		case RESULT_ABORTED:
+			retVal = -EIO;           // 5
+			break;
+
+		case RESULT_NO_MEM:
+			retVal = -ENOMEM;        // 12
+			break;
+
+		case RESULT_NO_THREAD:
+			retVal = -EAGAIN;        // 11
+			break;
+
+		default:
+			retVal = -ENODATA;       // 61
+			break;
+	}
+
+	atomic_set(&SOM_MCU_workRequest[real_cmd].onlyOneThread, 0);
+	return retVal;
 }
diff --git a/drivers/tty/mcu_comm/proto.c b/drivers/tty/mcu_comm/proto.c
index 774885b..1d1863a 100644
--- a/drivers/tty/mcu_comm/proto.c
+++ b/drivers/tty/mcu_comm/proto.c
@@ -1,6 +1,8 @@
 #include "workArray.h"
 #include "proto.h"
 
+const char idexxmcu_proto_c_version[] = "0.2.1-m";
+
 // the work array -- interface between protocol side (in this file) and ioctl's
 volatile WorkElement SOM_MCU_workRequest[NUMBER_OF_SOM_IOCTLS];
 
@@ -16,6 +18,16 @@ SOM_MCU_ioctl_descriptor ioctlDefinition[NUMBER_OF_SOM_IOCTLS] =    // indexed b
      {MSG_TYPE_INDICATORS,    PROTO_IND_CMD_LED_GET,             0,                            PROTO_IND_CMD_LED_STATUS,          sizeof(IndLEDCmd)},
      {MSG_TYPE_INDICATORS,    PROTO_IND_CMD_BUZZER_GET,          0,                            PROTO_IND_CMD_BUZZER_STATUS,       sizeof(IndBuzzerCmd)},
      {MSG_TYPE_INDICATORS,    PROTO_IND_CMD_PULSE_TRAIN_GET,     0,                            PROTO_IND_CMD_PULSE_TRAIN_STATUS,  sizeof(IndPulseTrainCmd)},
+	{MSG_TYPE_INDICATORS,    PROTO_IND_CMD_PULSE_TRAIN_DEF_GET, 1,                            PROTO_IND_CMD_PULSE_TRAIN_DEF,     sizeof(IndPulseTrainDefCmd)},
+	{MSG_TYPE_INDICATORS,    PROTO_IND_CMD_PULSE_TRAIN_DEF_SET, sizeof(IndPulseTrainDefCmd),  0xFF,                              0},
+	{0xFF},        // IND_CMD_PLACEHOLDER3
+	{0xFF},        // IND_CMD_PLACEHOLDER4
+	{0xFF},        // IND_CMD_PLACEHOLDER5
+	{0xFF},        // IND_CMD_PLACEHOLDER6
+	{0xFF},        // IND_CMD_PLACEHOLDER7
+	{0xFF},        // IND_CMD_PLACEHOLDER8
+	{0xFF},        // IND_CMD_PLACEHOLDER9
+	{0xFF},        // IND_CMD_PLACEHOLDER10
 
      // system ioctl's
      {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_SOM_IS_UP,           0,                            0xFF,                              0},
@@ -26,28 +38,112 @@ SOM_MCU_ioctl_descriptor ioctlDefinition[NUMBER_OF_SOM_IOCTLS] =    // indexed b
 	{MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_GET_STATS3,          0,                            PROTO_SYS_CMD_STATS3,              sizeof(SysStats3Cmd)},
 	{MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_GET_STATS4,          0,                            PROTO_SYS_CMD_STATS4,              sizeof(SysStats4Cmd)},
      {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_ZAP_STATS,           0,                            0xFF,                              0},
+     {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_EPROM_PAGE_GET,      1,                            PROTO_SYS_CMD_EPROM_PAGE,          sizeof(SysEpromCmd)},
+     {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_EPROM_PAGE_SET,      sizeof(SysEpromCmd),          0xFF,                              0},
+     {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_EPROM_PAGE_ERASE,    1,                            0xFF,                              0},
+     {MSG_TYPE_SYSTEM,        PROTO_SYS_CMD_STACK_SIZES_GET,     0,                            PROTO_SYS_CMD_STACK_SIZES,         sizeof(SysStacksCmd)},
+	{0xFF},        // SYS_CMD_PLACEHOLDER2
+	{0xFF},        // SYS_CMD_PLACEHOLDER3
+	{0xFF},        // SYS_CMD_PLACEHOLDER4
+	{0xFF},        // SYS_CMD_PLACEHOLDER5
+	{0xFF},        // SYS_CMD_PLACEHOLDER6
+	{0xFF},        // SYS_CMD_PLACEHOLDER7
+	{0xFF},        // SYS_CMD_PLACEHOLDER8
+	{0xFF},        // SYS_CMD_PLACEHOLDER9
+	{0xFF},        // SYS_CMD_PLACEHOLDER10
 
      // motor ioctl's
-     {MSG_TYPE_MOTOR,         0xFF,                                        0,                   PROTO_MOTOR_CMD_CURRENT_PROFILE,  sizeof(MotorCurProfCmd)},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ADC_OFFSET_GET,              0,                            PROTO_MOTOR_CMD_ADC_OFFSET_VALUE,  2},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_GOTO,                        sizeof(MotorGotoCmd),         0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_BRAKE,           0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_POWEROFF,        0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_CCW,             0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_CW,              0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_PWM,             sizeof(MotorPWMCmd),          0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,   0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,    0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_ADC_OFF,         0,                            0xFF,                              0},
-     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_ADC_ON,          0,                            0xFF,                              0},
+     {MSG_TYPE_MOTOR,         0xFF,                                        0,                   PROTO_MOTOR_CMD_CURRENT_PROFILE,                 sizeof(MotorCurProfCmd)},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ADC_OFFSET_GET,              0,                            PROTO_MOTOR_CMD_ADC_OFFSET_VALUE,       2},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_GOTO,                        sizeof(MotorGotoCmd),         0xFF,                                   0},  // goto
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_GOTO,                        sizeof(MotorGotoCmd),         0xFF,                                   0},  // goto with profile
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_BRAKE,           0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_POWEROFF,        0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_CCW,             0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_CW,              0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_PWM,             sizeof(MotorPWMCmd),          0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,   0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,    0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_ADC_OFF,         0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_SOM_CONTROL_ADC_ON,          0,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_STALL_CURRENT_GET,           0,                            PROTO_MOTOR_CMD_STALL_CURRENT,          2},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_STALL_CURRENT_SET,           2,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ALL_PARMS_GET,               0,                            PROTO_MOTOR_CMD_ALL_PARMS,              sizeof(MotorAllParmsCmd)},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ALL_PARMS_SET,               sizeof(MotorAllParmsCmd),     0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_STALL_SAMPLES_GET,           0,                            PROTO_MOTOR_CMD_STALL_SAMPLES,          2},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_STALL_SAMPLES_SET,           2,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_NO_STALL_CURRENT_GET,        0,                            PROTO_MOTOR_CMD_NO_STALL_CURRENT,       2},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_NO_STALL_CURRENT_SET,        2,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_NO_STALL_SAMPLES_GET,        0,                            PROTO_MOTOR_CMD_NO_STALL_SAMPLES,       2},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_NO_STALL_SAMPLES_SET,        2,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_SNAP_GET,            0,                            PROTO_MOTOR_CMD_TIMEOUT_SNAP,           1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_SNAP_SET,            1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_HOME_GET,            0,                            PROTO_MOTOR_CMD_TIMEOUT_HOME,           1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_HOME_SET,            1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_UP_GET,              0,                            PROTO_MOTOR_CMD_TIMEOUT_UP,             1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_UP_SET,              1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_DOWN_GET,            0,                            PROTO_MOTOR_CMD_TIMEOUT_DOWN,           1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_TIMEOUT_DOWN_SET,            1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_MAX_PWM_GET,                 0,                            PROTO_MOTOR_CMD_MAX_PWM,                2},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_MAX_PWM_SET,                 2,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_FREQ_GET,                    0,                            PROTO_MOTOR_CMD_FREQ,                   4},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_FREQ_SET,                    4,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ACC_PROF_GET,                0,                            PROTO_MOTOR_CMD_ACC_PROF,               1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ACC_PROF_SET,                1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ACC_STEP_GET,                0,                            PROTO_MOTOR_CMD_ACC_STEP,               1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ACC_STEP_SET,                1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_DEC_PROF_GET,                0,                            PROTO_MOTOR_CMD_DEC_PROF,               1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_DEC_PROF_SET,                1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_DEC_STEP_GET,                0,                            PROTO_MOTOR_CMD_DEC_STEP,               1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_DEC_STEP_SET,                1,                            0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_UP_DIR_GET,                  0,                            PROTO_MOTOR_CMD_UP_DIR,                 1},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_UP_DIR_SET,                  1,                            0xFF,                                   0},
+     {MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_PROFILE_ARRAY_GET,	          1,                            PROTO_MOTOR_CMD_PROFILE_ARRAY,          sizeof(MotorProfileArrayCmd)},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_PROFILE_ARRAY_SET,           sizeof(MotorProfileArrayCmd), 0xFF,                                   0},
+	{MSG_TYPE_MOTOR,         PROTO_MOTOR_CMD_ALL_SENSORS_GET,             0,                            PROTO_MOTOR_CMD_ALL_SENSORS,            sizeof(MotorAllSensorsCmd)},
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER4
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER5
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER6
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER7
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER8
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER9
+	{0xFF},        // MOTOR_CMD_PLACEHOLDER10
+
+     // battery ioctl's
+     {MSG_TYPE_BATTERY,       PROTO_BATT_CMD_GET_STATUS,                   0,                  PROTO_BATT_CMD_STATUS,             sizeof(BattStatusCmd)},
+     {MSG_TYPE_BATTERY,       PROTO_BATT_CMD_GET_GG_VERSION,               0,                  PROTO_BATT_CMD_GG_VERSION,         sizeof(BattGGVersionCmd)},
+     {0xFF},        // PROTO_BATT_CMD_GET_GG_DFI_CHECKSUM
+     {0xFF},        // PROTO_BATT_CMD_GG_DFI_FLASH
+     {MSG_TYPE_BATTERY,       PROTO_BATT_CMD_FS_PKT,                    0xFE,                            0xFF,                              0},
+     {MSG_TYPE_BATTERY,       PROTO_BATT_CMD_OVERRIDE_CHARGE_RATE,         1,                            0xFF,                              0},
+	{0xFF},        // BATT_CMD_PLACEHOLDER3,
+	{0xFF},        // BATT_CMD_PLACEHOLDER4,
+	{0xFF},        // BATT_CMD_PLACEHOLDER5,
+	{0xFF},        // BATT_CMD_PLACEHOLDER6,
+	{0xFF},        // BATT_CMD_PLACEHOLDER7,
+	{0xFF},        // BATT_CMD_PLACEHOLDER8,
+	{0xFF},        // BATT_CMD_PLACEHOLDER9,
+	{0xFF},        // BATT_CMD_PLACEHOLDER10,
+
      {MSG_TYPE_NONE,          0xFF,                                        0,                            0xFF,                    sizeof(ProtStat1Cmd)},   // PROT_CMD_GET_STATISTICS1
      {MSG_TYPE_NONE,          0xFF,                                        0,                            0xFF,                    sizeof(ProtStat2Cmd)},   // PROT_CMD_GET_STATISTICS2
      {MSG_TYPE_NONE,          0xFF,                                        0,                            0xFF,                    sizeof(ProtStat3Cmd)},   // PROT_CMD_GET_STATISTICS3
      {MSG_TYPE_NONE,          0xFF,                                        0,                            0xFF,                              0},            // PROT_CMD_ZAP_STATISTICS
+     {MSG_TYPE_NONE,          0xFF,                                        0,                            0xFF,                    DRIVER_VERSION_SIZE},    // PROT_CMD_GET_DRIVER_VERSION
+	{0xFF},        // PROT_CMD_PLACEHOLDER1
+	{0xFF},        // PROT_CMD_PLACEHOLDER2
+	{0xFF},        // PROT_CMD_PLACEHOLDER3
+	{0xFF},        // PROT_CMD_PLACEHOLDER4
+	{0xFF},        // PROT_CMD_PLACEHOLDER5
+	{0xFF},        // PROT_CMD_PLACEHOLDER6
+	{0xFF},        // PROT_CMD_PLACEHOLDER7
+	{0xFF},        // PROT_CMD_PLACEHOLDER8
+	{0xFF},        // PROT_CMD_PLACEHOLDER9
+	{0xFF},        // PROT_CMD_PLACEHOLDER10
 };
 
 // notifications. one array indexed by command per message type. 0 = invalid.
-static u8 NotIndicators[0x100] = 
+static u8 NotIndicators[0x100] =
 {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -58,10 +154,10 @@ static u8 NotIndicators[0x100] =
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, IND_NOTIFY_INVALID_COMMAND,
 };
-static u8 NotSystem[0x100] = 
+static u8 NotSystem[0x100] =
 {
      0, SYS_NOTIFY_BUTTON_UP, SYS_NOTIFY_CORRUPTION, SYS_NOTIFY_POWER_UP, 0, SYS_NOTIFY_POWER_FAIL, SYS_NOTIFY_SHUTDOWN, 0, 0, 0, SYS_NOTIFY_WATCHDOG_RESET, 0, 0, 0, 0, 0,
-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     0, 0, 0, 0, 0, 0, 0, SYS_NOTIFY_INVALID_EPROM_PAGE, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -69,10 +165,10 @@ static u8 NotSystem[0x100] =
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SYS_NOTIFY_INVALID_COMMAND,
 };
-static u8 NotMotor[0x100] = 
+static u8 NotMotor[0x100] =
 {
      0, 0, 0, 0, 0, MOTOR_NOTIFY_GOTO_COMPLETE, MOTOR_NOTIFY_SNAP_INSERTED, MOTOR_NOTIFY_SNAP_EJECTED, MOTOR_NOTIFY_HOME_POSITION_REACHED,
-     MOTOR_NOTIFY_HOME_POSITION_LEFT, MOTOR_NOTIFY_SNAP_POSITION_REACHED, MOTOR_NOTIFY_SNAP_POSITION_LEFT, MOTOR_NOTIFY_SNAP_DOOR_UP, 
+     MOTOR_NOTIFY_HOME_POSITION_LEFT, MOTOR_NOTIFY_SNAP_POSITION_REACHED, MOTOR_NOTIFY_SNAP_POSITION_LEFT, MOTOR_NOTIFY_SNAP_DOOR_UP,
      MOTOR_NOTIFY_SNAP_DOOR_DOWN, MOTOR_NOTIFY_MOTOR_STALL_DETECTED, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -82,10 +178,11 @@ static u8 NotMotor[0x100] =
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, MOTOR_NOTIFY_INVALID_COMMAND,
 };
-static u8 NotBattery[0x100] = 
+static u8 NotBattery[0x100] =
 {
-     0, BATT_NOTIFY_CHARGER_IN, BATT_NOTIFY_CHARGER_OUT, BATT_NOTIFY_100mA, BATT_NOTIFY_500mA, BATT_NOTIFY_1A, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     0, BATT_NOTIFY_CHARGER_IN, BATT_NOTIFY_CHARGER_OUT, BATT_NOTIFY_100mA, BATT_NOTIFY_500mA, BATT_NOTIFY_1A, 0, 0,
+     BATT_NOTIFY_GG_ERROR, 0, 0, 0, 0, 0, 0, 0,
+     0, BATT_NOTIFY_FS_PKT_STATUS, 0, BATT_NOTIFY_CHARGE_OFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -139,6 +236,7 @@ static u8 rx_notification[MAX_NOTIFICATION_SIZE]; // temporary buffer to store n
 static u8 rx_curProfTempBuf[PROF_NUM_SAMPLE_PAIRS * 4];     // buffer to store current profile data while the ioctl handler is busy handling its regular buffer
 #pragma pack(pop)
 static volatile u8 rx_curProfTempBufUsed;         // 1 = rx_curProfTempBuf is used, 0 = not used
+static volatile u8 rx_curProfOrder;               // 1 = rx_curProfTempBuf was filled before the regular buffer, 0 = after
 static u32 rx_tempBufCnt;                         // number ofr times rx_curProfTempBuf was used
 static u32 rx_longNotCnt;                         // number of notifications too long to be accepted
 static u8 rx_curProfLossNotified;                 // 1 = notification about uncounsumed current profile packet sent, 0 = not yet
@@ -331,7 +429,7 @@ static inline u8 AddToSequence(u8 seq, u8 increment)
      return temp2;
 }
 
-// returns signed difference of two sequence numbers; negative is the first is the earlier, positive if it is the later
+// returns signed difference of two sequence numbers; negative if the first is the earlier, positive if it is the later
 static s8 SeqDiff(u8 seq1, u8 seq2)
 {
 	union {s8 withSign; u8 noSign;} temp;
@@ -474,7 +572,7 @@ static int ReleaseIoctl(ResultCode result, int index)
                ret = 1;
           }
      )
-     
+
      if (ret)
      {
           SOM_MCU_workRequest[index].retValue = result;
@@ -489,7 +587,7 @@ static int ReleaseIoctl(ResultCode result, int index)
 }
 
 // returns -1 if the sequence number to be marked as acked is invalid (also causes link reset), or index into the work request array of the entry with this sequence number,
-// or 0xFF if the entry is no longer valid
+// or 0xFF if the entry has already been marked
 static int MarkAsAcked(u8 sequence)
 {
      int i, j, k, l;
@@ -506,18 +604,11 @@ static int MarkAsAcked(u8 sequence)
      else
 	{
 		// maintain unacked window
-		if ((k = tx_unackedBuf[l = GetUnackedIndex(i)]) != 0xFF)     // 0xFF means this has been already acked
-			tx_unackedBuf[l] = 0xFF;
-
-          if (!i)   // start of the window has been acknowledged -- can advance the window
-		{
-			for (; i < j && tx_unackedBuf[l] == 0xFF; ++i, l = l == TX_UNACKED_WINDOW - 1 ? 0 : l + 1);   // go to the 1st not-yet-acknowledged sequence
-			j = AddToSequence(tx_unackedWindowStart, i);
-			AtomicOp(
-				tx_unackedWindowStart = j;
-				tx_unackedBufInd = l;
-			)
-		}
+		l = GetUnackedIndex(i);
+          AtomicOp(
+		     if ((k = tx_unackedBuf[l]) != 0xFF)     // 0xFF means this has been already acked
+			     tx_unackedBuf[l] = 0xFF;
+          )
 	}
 
      return k;
@@ -801,11 +892,19 @@ static void rxStateMachine(u8 byte)
                                                        rx_curProfLossNotified = 0;
                                                        if (rx_dataPtr == rx_curProfTempBuf)
                                                        {
-                                                            rx_curProfTempBufUsed = 1;
                                                             AtomicOp(++rx_tempBufCnt)
+                                                            AtomicOp(
+                                                                 rx_curProfTempBufUsed = 1;
+                                                                 rx_curProfOrder = SOM_MCU_workRequest[i].state == RS_ACKED;
+											     )
+                                                            if (rx_curProfOrder)
+                                                                 ReleaseIoctl(RESULT_SUCCESS, i);
                                                        }
+											else
+                                                            ReleaseIoctl(RESULT_SUCCESS, i);
                                                   }
-                                                  ReleaseIoctl(RESULT_SUCCESS, i);
+										else
+                                                       ReleaseIoctl(RESULT_SUCCESS, i);
                                              }
                                         }
                                         else           // notification
@@ -822,13 +921,26 @@ static void rxStateMachine(u8 byte)
                                                   byte = rx_dataPtr[rx_cmd];
                                                   if (!byte)
                                                        not_fifo_in_one(NOTIFY_UNKNOWN);
-                                                  else if (byte == MOTOR_NOTIFY_GOTO_COMPLETE)      // this is the only notification with data
+                                                  else switch (byte)
                                                   {
-                                                       rx_notification[0] = MOTOR_NOTIFY_GOTO_COMPLETE;
-                                                       not_fifo_in_many(rx_notification, 4);
+                                                       case MOTOR_NOTIFY_GOTO_COMPLETE:
+                                                       case BATT_NOTIFY_GG_ERROR:
+											case BATT_NOTIFY_FS_PKT_STATUS:
+                                                            rx_notification[0] = byte;
+                                                            not_fifo_in_many(rx_notification, 4);
+                                                            break;
+
+                                                       case IND_NOTIFY_INVALID_COMMAND:
+                                                       case SYS_NOTIFY_INVALID_COMMAND:
+                                                       case MOTOR_NOTIFY_INVALID_COMMAND:
+                                                       case BATT_NOTIFY_INVALID_COMMAND:
+                                                            rx_notification[0] = byte;
+                                                            not_fifo_in_many(rx_notification, 2);
+                                                            break;
+
+                                                       default:
+                                                            not_fifo_in_one(byte);
                                                   }
-                                                  else
-                                                       not_fifo_in_one(byte);
                                              }
                                         }
                                    }
@@ -884,14 +996,12 @@ static int NotificationThread(void *ptr)
           {
                notFifo[2] = 0;
                SOM_MCU_workRequest[0].outBuffer[0] = PROTOCOL_NOTIFY_LOST_NOTIFICATIONS;
-               INIT_COMPLETION(notHandlerSemaphore);
                ReleaseIoctl(RESULT_SUCCESS,0);
           }
           else if (ackFifo[2])
           {
                ackFifo[2] = 0;
                SOM_MCU_workRequest[0].outBuffer[0] = PROTOCOL_NOTIFY_LOST_ACKS;
-               INIT_COMPLETION(notHandlerSemaphore);
                ReleaseIoctl(RESULT_SUCCESS,0);
           }
           else
@@ -901,13 +1011,23 @@ static int NotificationThread(void *ptr)
                if (byte != -1)     // FIFO was not empty
                {
                     SOM_MCU_workRequest[0].outBuffer[0] = byte;
-                    if (byte == MOTOR_NOTIFY_GOTO_COMPLETE) // this is the only notification with data
+                    switch (byte)  // parse for notifications with data
                     {
-                         SOM_MCU_workRequest[0].outBuffer[1] = not_fifo_out();
-                         SOM_MCU_workRequest[0].outBuffer[2] = not_fifo_out();
-                         SOM_MCU_workRequest[0].outBuffer[3] = not_fifo_out();
+                         case MOTOR_NOTIFY_GOTO_COMPLETE:
+                         case BATT_NOTIFY_GG_ERROR:
+					case BATT_NOTIFY_FS_PKT_STATUS:
+                              SOM_MCU_workRequest[0].outBuffer[1] = not_fifo_out();
+                              SOM_MCU_workRequest[0].outBuffer[2] = not_fifo_out();
+                              SOM_MCU_workRequest[0].outBuffer[3] = not_fifo_out();
+                              break;
+
+                         case IND_NOTIFY_INVALID_COMMAND:
+                         case SYS_NOTIFY_INVALID_COMMAND:
+                         case MOTOR_NOTIFY_INVALID_COMMAND:
+                         case BATT_NOTIFY_INVALID_COMMAND:
+                              SOM_MCU_workRequest[0].outBuffer[1] = not_fifo_out();
+                              break;
                     }
-                    INIT_COMPLETION(notHandlerSemaphore);
                     ReleaseIoctl(RESULT_SUCCESS,0);
                }
           }
@@ -1001,7 +1121,7 @@ static void ResetCleanup(void)
           ackFifo[1] = 0;
           ackFifo[2] = 0;
      )
-     
+
 	for (i = 0; i < RX_PACKET_MEMORY; ++i)
           rx_old_seq[i] = 0;
 
@@ -1020,8 +1140,7 @@ static void ResetCleanup(void)
 // the worker thread
 static int TxThread(void *ptr)
 {
-     int i, j, k, state;
-     unsigned long flags;
+     int i, j, k, l, state;
 
      while (!kthread_should_stop())
      {
@@ -1046,7 +1165,7 @@ static int TxThread(void *ptr)
                {
                     state = SOM_MCU_workRequest[i].state;   // for atomicity during multiple operations
                     if (state != RS_IDLE && ioctlDefinition[i].cmd != 0xFF)     // an active ioctl that transmits a command
-                    {     
+                    {
                          if (state >= RS_ACCEPTED)          // is being worked on
                          {
                               if (check_delay(&SOM_MCU_workRequest[i].ioctlTimeout))     // ioctl has expired
@@ -1058,27 +1177,26 @@ static int TxThread(void *ptr)
                                    }
                               }
 
-                              if (MonitorReTransmission(&SOM_MCU_workRequest[i].reXmitCnt, &SOM_MCU_workRequest[i].ackTimeout, 1, i))
+                              if (SOM_MCU_workRequest[i].state < RS_ACKED && MonitorReTransmission(&SOM_MCU_workRequest[i].reXmitCnt, &SOM_MCU_workRequest[i].ackTimeout, 1, i))
                                    return 0;
                          }
                          else                               // has not been transmitted yet
 				     {
-                              // make sure that the unacked window does not shift while we are here
-                              raw_local_irq_save(flags);
-						do
+                              // see if we can advance the unacked window
+			               for (j = SeqDiff(tx_seq, tx_unackedWindowStart), k = 0, l = tx_unackedBufInd;
+				               k < j && tx_unackedBuf[l] == 0xFF; ++k, l = l == TX_UNACKED_WINDOW - 1 ? 0 : l + 1);   // go to the 1st not-yet-acknowledged sequence
+                              if (k)    // can advance the window
+		                    {
+			                    j = AddToSequence(tx_unackedWindowStart, k);
+			                    AtomicOp(
+				                    tx_unackedWindowStart = j;
+				                    tx_unackedBufInd = l;
+			                    )
+		                    }
+
+                              if ((j = SeqDiff(tx_seq, tx_unackedWindowStart)) < TX_UNACKED_WINDOW) // there is room in the unacked window -- accept the ioctl
 						{
-                                   raw_local_irq_restore(flags);
-                                   k = tx_unackedWindowStart;
-						     if ((j = SeqDiff(tx_seq, k)) >= TX_UNACKED_WINDOW)     // cannot transmit now
-                                        break;
-                                   raw_local_irq_save(flags);
-						} while (k != tx_unackedWindowStart);
-
-                              if (j  < TX_UNACKED_WINDOW)
-						{
-                                   // here interrupts are disabled
 					          tx_unackedBuf[GetUnackedIndex(j)] = i;
-                                   raw_local_irq_restore(flags);
                                    SOM_MCU_workRequest[i].seq = tx_seq;
                                    AtomicOp(
                                         if (SOM_MCU_workRequest[i].state == RS_SUBMITTED)
@@ -1097,7 +1215,7 @@ static int TxThread(void *ptr)
      }
      return 0;
  }
- 
+
 static unsigned char res_char = RESET_CHAR;
 static unsigned char esc_char = ESC_CHAR;
 static unsigned char stx_char = STX_CHAR;
@@ -1160,10 +1278,22 @@ static int XmitThread(void *ptr)
           if (my_tty->ops->write_room(my_tty) <= 0 && WaitForCompletionWithStopCheck(&canWriteSemaphore))
                return 0;
 
-          // abort normal processing if protocol-bound processing is pending; return to normal processing if protocol-bound processing is done
-	     if ((tx_type == TX_TYPE_ACK || tx_type == TX_TYPE_COMMAND) && (LinkLineInException(&rx_hardError) || LinkLineInException(&tx_hardError)) ||
-	               tx_type != TX_TYPE_ACK && tx_type != TX_TYPE_COMMAND && LinkStateRepaired())
+          // abort normal processing if protocol-bound processing is pending; indicate to the TX task that we have finished the previous command (or it may hang waiting for it)
+	     if ((tx_type == TX_TYPE_ACK || tx_type == TX_TYPE_COMMAND) && (LinkLineInException(&rx_hardError) || LinkLineInException(&tx_hardError)))
+	     {
 	          tx_progress = RXTX_IDLE;
+               complete(&msgSemaphore);
+	     }
+
+          // return to normal processing if protocol-bound processing is done; if still doing protocol-bound processing, release the TX task in case it is trying to submit
+          // a normal command (or it may hang waiting for it)
+	     if (tx_type != TX_TYPE_ACK && tx_type != TX_TYPE_COMMAND)
+	     {
+               if (LinkStateRepaired())
+	               tx_progress = RXTX_IDLE;
+               else
+                    complete(&msgSemaphore);
+	     }
 
           switch(tx_progress++)
           {
@@ -1252,7 +1382,7 @@ static int XmitThread(void *ptr)
                     break;
 
                case RXTX_DATA_SIZE:
-                    byte = ioctlDefinition[tx_xmittingInd].cmdLen + 1;
+                    byte = SOM_MCU_workRequest[tx_xmittingInd].inSize + 1;
                     if (TXParseEsc(byte))
                          --tx_progress;
                     else
@@ -1265,7 +1395,7 @@ static int XmitThread(void *ptr)
                     else
                     {
                          tx_crc_value = crc16_byte(tx_crc_value, ioctlDefinition[tx_xmittingInd].cmd);
-                         if (!ioctlDefinition[tx_xmittingInd].cmdLen)
+                         if (!SOM_MCU_workRequest[tx_xmittingInd].inSize)
                               tx_progress = RXTX_CHKSUM1;
                          else
                               byte = 0;
@@ -1278,7 +1408,7 @@ static int XmitThread(void *ptr)
                     else
                     {
                          tx_crc_value = crc16_byte(tx_crc_value, SOM_MCU_workRequest[tx_xmittingInd].inBuffer[byte]);
-                         if (++byte < ioctlDefinition[tx_xmittingInd].cmdLen)
+                         if (++byte < SOM_MCU_workRequest[tx_xmittingInd].inSize)
                               --tx_progress;
                     }
                     break;
@@ -1426,7 +1556,7 @@ void SOM_MCU_SubmitToProto(int ind)
                     )
                     copy_to_user(workPtr->output, workPtr->outBuffer, sizeof(ProtStat3Cmd));
                     break;
-               
+
                case PROT_CMD_ZAP_STATISTICS:
                     AtomicOp(
                          rx_timeoutCnt = 0;
@@ -1471,14 +1601,24 @@ void SOM_MCU_SubmitToProto(int ind)
                          rx_tempBufCnt = 0;
                     )
                     break;
+
+               case PROT_CMD_GET_DRIVER_VERSION:
+                    copy_to_user(workPtr->output, idexxmcu_proto_c_version, sizeof(idexxmcu_proto_c_version));
+				break;
           }
           workPtr->retValue = RESULT_SUCCESS;
           return;
      }
 
+     if (ind == MOTOR_CMD_GOTO_WITH_PROFILE && SOM_MCU_workRequest[MOTOR_CMD_ACCEPT_PROFILE].state != RS_ACKED)
+     {
+          workPtr->retValue = RESULT_NO_THREAD;
+          return;
+     }
+
      // copy input data into kernel space if needed
-     if (ioctlDefinition[ind].cmdLen)
-          copy_from_user(workPtr->inBuffer, workPtr->input, ioctlDefinition[ind].cmdLen);
+     if (workPtr->inSize)
+          copy_from_user(workPtr->inBuffer, workPtr->input, workPtr->inSize);
 
      // indicate we are ready
      INIT_COMPLETION(workPtr->workIndicator);
@@ -1514,14 +1654,25 @@ void SOM_MCU_SubmitToProto(int ind)
           u16 workBuf[PROF_NUM_SAMPLE_PAIRS * 2];                // temporary buffer for decompression of the current profile packets
           MotorCurProfCmd *profPtr;                              // view of a current profile packet
           int i;                                                 // general purpose counter
-          int numSamples;                                        // number of samples to put in the user buffer from the current packet
+          u8  numSamples;                                        // number of samples to put in the user buffer from the current packet
           int tempBufUsed = 0;     // switch controlling if we are using the extra buffer (accepts one current profile packet while we are busy processing the previous one)
-          
+
           // initialize user space buffer
           copy_from_user(&kernProf, workPtr->output, sizeof(kernProf) - sizeof(kernProf.samples));
           kernProf.numSamples = 0;
           kernProf.numMissedSamples = 0;
 
+		// ignore a possible spurious regular buffer caused by the extra buffer intended for the previous invocation of this ioctl and received in between the invocations
+          if (rx_curProfTempBufUsed && rx_curProfOrder)
+		{
+               AtomicOp(
+                    workPtr->state = RS_ACKED;
+                    rx_curProfTempBufUsed = 0;
+			)
+               if (waitWithSignal(workPtr))
+                    return;
+		}
+
           // accumulate sample data from current profile packets
           for (;;)
           {
@@ -1530,27 +1681,27 @@ void SOM_MCU_SubmitToProto(int ind)
 
                // calculate the smaller of packet samples and user buffer room
                numSamples = profPtr->numSamples & 0x7F;
-               if (room < numSamples * 2)
-                    numSamples = room / 2;
-               
-               // maintein user buffer header:
+               if (room < numSamples << 1)
+                    numSamples = room >> 1;
+
+               // maintain user buffer header:
                kernProf.numSamples += numSamples;
                if (profPtr->seqNum != seq)
-                    kernProf.numMissedSamples += PROF_NUM_SAMPLE_PAIRS * 2 * (((u32)profPtr->seqNum | 0x10000) - seq & 0xFFFF);   // sequence numbers can roll over
+                    kernProf.numMissedSamples += (PROF_NUM_SAMPLE_PAIRS << 1) * (((u32)profPtr->seqNum | 0x10000) - seq & 0xFFFF);   // sequence numbers can roll over
 
                // reset sequence to start from the current packet
                seq = profPtr->seqNum + 1;
 
                // decompress samples
-               for (i = 0; i < numSamples; ++i)  
+               for (i = 0; i < numSamples; ++i)
                     workBuf[i] = i & 0x01 ? (u16)(profPtr->data[i/2][1] & 0x0F) << 8 | profPtr->data[i/2][2] : (u16)(profPtr->data[i/2][1] & 0xF0) << 4 | profPtr->data[i/2][0];
-             
+
                if (numSamples)
                     copy_to_user(dataPtr, workBuf, numSamples << 1);
 
                dataPtr += numSamples;
                room -= numSamples << 1;
-               
+
                if (numSamples != (profPtr->numSamples & 0x7F))   // we did not accept the whole packet because of lack of room
                {
                     copy_to_user(workPtr->output, &kernProf, sizeof(kernProf) - sizeof(kernProf.samples));
@@ -1565,17 +1716,33 @@ void SOM_MCU_SubmitToProto(int ind)
                     return;
                }
 
-               // if we have used the extra buffer, free it
+			// we are done with the current profile buffer -- allow refill
                if (tempBufUsed)
+			{
                     rx_curProfTempBufUsed = 0;
-
-               // get the next packet
-               INIT_COMPLETION(workPtr->workIndicator);
-               workPtr->state = RS_ACKED;
-               if (waitWithSignal(workPtr))
-                    return;
-
-               tempBufUsed = rx_curProfTempBufUsed;
+                    tempBufUsed = 0;
+                    if (waitWithSignal(workPtr))
+                         return;
+			}
+               else
+			{
+				AtomicOp(
+                         workPtr->state = RS_ACKED;
+                         tempBufUsed = rx_curProfTempBufUsed;
+				)
+                    if (!tempBufUsed)
+			     {
+                         if (waitWithSignal(workPtr))
+                              return;
+                         if (tempBufUsed = rx_curProfTempBufUsed)
+					{
+						if (rx_curProfOrder)
+                                   workPtr->state = RS_ACKED;
+						else
+                                   tempBufUsed = 0;
+					}
+			     }
+			}
           }
      }
      else if (ioctlDefinition[ind].rspLen)
diff --git a/drivers/tty/mcu_comm/proto.h b/drivers/tty/mcu_comm/proto.h
index bc4f895..0ad2ee0 100644
--- a/drivers/tty/mcu_comm/proto.h
+++ b/drivers/tty/mcu_comm/proto.h
@@ -1,181 +1,276 @@
-#ifndef SOM_MCU_PROTO_H
-#define SOM_MCU_PROTO_H
-
-#include <linux/irqflags.h>
-#include <linux/crc16.h>
-#include <linux/kthread.h>
-#include <linux/err.h>
-#include <asm/uaccess.h>
-
-#define AtomicOp(expr) {unsigned long flags;	raw_local_irq_save(flags); expr; raw_local_irq_restore(flags);}
-#define set_delay(tm, min, sec, ms) set_wakeup_delay(0, tm, min, sec, ms)
-#define check_delay(expr) (!timer_pending(expr))
-
-#define PROTO_FIFO_SIZE            64        // size of the FIFO's for ACK's and notifications
-#define STX_CHAR                   0x75      // start of packet character
-#define ESC_CHAR                   0x57      // escape character used in masking STX_CHAR occurring in packets
-#define RESET_CHAR                 0x5A      // protocol reset command
-#define ACK_CHAR                   0x7A      // acknowledge command
-#define PACKET_TIMEOUT             20        // maximum duration for a packet reception to occur in ms
-#define MAX_NOTIFICATION_SIZE      4         // maximum size of a notification
-#define RESET_TIMEOUT              150       // number of milliseconds in which to complete link reset
-#define ACK_RESEND_DELAY           40        // number of ms between message re-transmissions if no ACK is received
-#define MAX_TX_TRIES               3         // maximum number of message send attempts before a tx packet is discarded
-#define MAX_IOCTL_TIMEOUT          150       // number of ms to wait for IOCTL to complete
-#define RX_PACKET_MEMORY           4         // number of most recent received sequence-length-crc sets to retain for repeated ACK's
-#define TX_UNACKED_WINDOW          4         // maximum number of packets to transmit without waiting for an ACK
-
-// mapping of ioctl's to SOM-MCU UART transactions
-typedef struct
-{
-     u8             msgType;       // message type, 0xFE for any
-     u8             cmd;           // command to transmit to SOM, 0xFF for none
-     u8             cmdLen;        // length of data to send with the cmd, 0 for none
-     u8             rsp;           // command to receive from SOM in response, 0xFF for none, 0xFE for any
-     u8             rspLen;        // length of data to received with the rsp, 0 for none, 0xFE for variable
-
-} SOM_MCU_ioctl_descriptor;
-
-// Functional areas of processing distinguished by the comm protocol
-typedef enum
-{
-     MSG_TYPE_INDICATORS = 1,      // buzzer and LED
-     MSG_TYPE_SYSTEM,              // overall state and behaviour of the MCU
-     MSG_TYPE_MOTOR,               // motor control
-     MSG_TYPE_BATTERY,             // battery control
-     MSG_TYPE_NONE
-
-} MessageType;
-
-//============================================================================================
-// Definitions for MSG_TYPE_INDICATORS
-//============================================================================================
-typedef enum
-{
-     PROTO_IND_CMD_PULSE_TRAIN = 1,     // 1 initiate a train of on/off pulses on LED and/or buzzer
-     PROTO_IND_CMD_LED_SET,             // 2 set LED to a specific colour or turn it off
-     PROTO_IND_CMD_BUZZER_SET,          // 3 set buzzer to a specific frequency or turn it off
-     PROTO_IND_CMD_LED_GET,             // 4 request to provide the current state of the LED
-     PROTO_IND_CMD_LED_STATUS,          // 5 response to IND_CMD_LED_GET
-     PROTO_IND_CMD_BUZZER_GET,          // 6 request to provide the current state of the buzzer
-     PROTO_IND_CMD_BUZZER_STATUS,       // 7 response to IND_CMD_BUZZER_GET
-     PROTO_IND_CMD_PULSE_TRAIN_GET,     // 8 request to provide current state of pulse train
-     PROTO_IND_CMD_PULSE_TRAIN_STATUS,  // 9 response to IND_CMD_PULSE_TRAIN_GET
-
-} IndicatorCommand;
-
-//============================================================================================
-// Definitions for MSG_TYPE_SYSTEM
-//============================================================================================
-typedef enum
-{
-     PROTO_SYS_CMD_NOTIFY_BUTTON_UP = 1,     // 1 power button was pressed to wake up
-     PROTO_SYS_CMD_NOTIFY_CORRUPTION,        // 2 corruption of RAM or code bug detected
-     PROTO_SYS_CMD_NOTIFY_POWER_UP,          // 3 MCU is cold-starting
-     PROTO_SYS_CMD_SOM_IS_UP,                // 4 message from SOM that is has started up
-     PROTO_SYS_CMD_NOTIFY_POWER_FAIL,        // 5 battery power is failing
-     PROTO_SYS_CMD_NOTIFY_SHUTDOWN,          // 6 shutting down
-     PROTO_SYS_CMD_SHUTDOWN,                 // 7 command from SOM to shutdown
-	PROTO_SYS_CMD_GET_FW_VER,               // 8 command from SOM to get MCU's firmware version
-	PROTO_SYS_CMD_FW_NUMBERS,               // 9 response to SYS_CMD_GET_FW_VER
-	PROTO_SYS_CMD_NOTIFY_WATCHDOG_RESET,    // 10 watchdog reset occurred
-	PROTO_SYS_CMD_GET_STATS1,               // 11 get page 1 of statistics
-	PROTO_SYS_CMD_STATS1,                   // 12 response to SYS_CMD_GET_STATS1
-	PROTO_SYS_CMD_GET_STATS2,               // 13 get page 2 of statistics
-	PROTO_SYS_CMD_STATS2,                   // 14 response to SYS_CMD_GET_STATS2
-	PROTO_SYS_CMD_GET_STATS3,               // 15 get page 3 of statistics
-	PROTO_SYS_CMD_STATS3,                   // 16 response to SYS_CMD_GET_STATS3
-	PROTO_SYS_CMD_GET_STATS4,               // 17 get page 4 of statistics
-	PROTO_SYS_CMD_STATS4,                   // 18 response to SYS_CMD_GET_STATS4
-	PROTO_SYS_CMD_ZAP_STATS,                // 19 clear all statistics counters
-
-} SystemCommand;
-
-//============================================================================================
-// Definitions for MSG_TYPE_MOTOR
-//============================================================================================
-typedef enum
-{
-     PROTO_MOTOR_CMD_CURRENT_PROFILE = 1,              // 1 real time current current profile packet from MCU to SOM
-     PROTO_MOTOR_CMD_ADC_OFFSET_GET,                   // 2 request to provide ADC idle value
-     PROTO_MOTOR_CMD_ADC_OFFSET_VALUE,                 // 3 response to MOTOR_CMD_ADC_OFFSET_GET
-     PROTO_MOTOR_CMD_GOTO,                             // 4 move to home/to snap/up/down
-     PROTO_MOTOR_CMD_NOTIFY_GOTO_COMPLETE,             // 5 the above command complete
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_INSERTED,             // 6 cartridge has been inserted (switch closed)
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_EJECTED,              // 7 cartridge has been ejected (switch opened)
-     PROTO_MOTOR_CMD_NOTIFY_HOME_POSITION_REACHED,     // 8 home position hall effect sensor reached
-     PROTO_MOTOR_CMD_NOTIFY_HOME_POSITION_LEFT,        // 9 home position hall effect sensor left
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_POSITION_REACHED,     // 10 snap position hall effect sensor reached
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_POSITION_LEFT,        // 11 snap position hall effect sensor left
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_DOOR_UP,              // 12 the snap door is up (optical sensor)
-     PROTO_MOTOR_CMD_NOTIFY_SNAP_DOOR_DOWN,            // 13 the snap door is down (optical sensor)
-     PROTO_MOTOR_CMD_NOTIFY_MOTOR_STALL_DETECTED,      // 14 stall current detected
-     PROTO_MOTOR_CMD_SOM_CONTROL_BRAKE,                // 15 direct SOM control motor brake
-     PROTO_MOTOR_CMD_SOM_CONTROL_POWEROFF,             // 16 direct SOM control motor power off
-     PROTO_MOTOR_CMD_SOM_CONTROL_CCW,                  // 17 direct SOM control motor counter-clockwise
-     PROTO_MOTOR_CMD_SOM_CONTROL_CW,                   // 18 direct SOM control motor clockwise
-     PROTO_MOTOR_CMD_SOM_CONTROL_PWM,                  // 19 direct SOM control set PWM duty cycle and frequency
-     PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,        // 20 direct SOM control disable motor
-     PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,         // 21 direct SOM control enable motor
-     PROTO_MOTOR_CMD_SOM_CONTROL_ADC_OFF,              // 22 direct SOM control disable current profile transmission
-     PROTO_MOTOR_CMD_SOM_CONTROL_ADC_ON,               // 23 direct SOM control enable current profile transmission
-
-} MotorCommand;
-
-#pragma pack(push, 1)
-typedef struct      // MOTOR_CMD_CURRENT_PROFILE format
-{
-     u16  seqNum;                            // sequence number of this packet in the stream of current profile packets; starts with 1
-     u8   numSamples;                        // number of samples in this packet in bits 7-0, if bit 8 is set, this is the last packet in the profile
-#define PROF_NUM_SAMPLE_PAIRS 15             // number of sample pairs in one current profile packet
-     u8   data[PROF_NUM_SAMPLE_PAIRS][3];    // 2 12-bit samples are packed in 3 bytes
-
-} MotorCurProfCmd;
-#pragma pack(pop)
-
-// input packet parser states
-typedef enum   // the order of definitions in this enum is significant; if changed, bith rx and tx state machines must be changed
-{
-     RXTX_IDLE,          // the communications state machine is waiting to start deciphering a message
-     RXTX_MESSAGE_TYPE,  // message type
-     RXTX_SEQ,           // sequence Number
-     RXTX_DATA_SIZE,     // size of the packet's payload
-     RXTX_CMD,           // command of a particular message type
-     RXTX_DATA,          // data for the command
-     RXTX_CHKSUM1,       // first CRC-16 byte
-     RXTX_CHKSUM2,       // second CRC-16 byte
-
-} RxTxState;
-
-// hard error processing states
-typedef enum
-{
-     HARD_ERROR_NONE,              // all good
-     HARD_ERROR_PROCESSING,        // encountered a hard error
-	HARD_ERROR_TRANSMITTED,       // transmitted reset command
-     HARD_ERROR_FAILED,            // failed in trying to reset the link after hard error
-
-} ProtocolHardErrorState;
-
-// ESC and STX parsing states
-typedef enum
-{
-     ESC_PARSER_LOOK_FOR_ESC,      // passing bytes through; ESC_CHAR will be held
-     ESC_PARSER_ESC_FOUND,         // holding an ESC_CHAR in anticipation of the next byte
-     ESC_PARSER_SOLO_ESC,          // ESC_CHAR not followed by either ESC_CHAR or STX_CHAR
-
-} EscParserState;
-
-typedef enum
-{
-     TX_TYPE_NONE,       // transmitting reset command
-     TX_TYPE_RESET,      // transmitting reset command
-     TX_TYPE_ACK_RESET,  // transmitting an ACK to a reset command
-     TX_TYPE_ACK,        // transmitting an ACK to a command
-     TX_TYPE_COMMAND,    // transmitting a command
-
-} TxType;
-
-extern SOM_MCU_ioctl_descriptor ioctlDefinition[NUMBER_OF_SOM_IOCTLS];
-
-#endif    // SOM_MCU_PROTO_H
+#ifndef SOM_MCU_PROTO_H
+#define SOM_MCU_PROTO_H
+
+static const char idexxmcu_proto_h_version[] = "0.2.1-m";
+
+#include <linux/irqflags.h>
+#include <linux/crc16.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <asm/uaccess.h>
+
+#define AtomicOp(expr) {unsigned long flags;	raw_local_irq_save(flags); expr; raw_local_irq_restore(flags);}
+#define set_delay(tm, min, sec, ms) set_wakeup_delay(0, tm, min, sec, ms)
+#define check_delay(expr) (!timer_pending(expr))
+
+#define PROTO_FIFO_SIZE            64        // size of the FIFO's for ACK's and notifications
+#define STX_CHAR                   0x75      // start of packet character
+#define ESC_CHAR                   0x57      // escape character used in masking STX_CHAR occurring in packets
+#define RESET_CHAR                 0x5A      // protocol reset command
+#define ACK_CHAR                   0x7A      // acknowledge command
+#define PACKET_TIMEOUT             60        // maximum duration for a packet reception to occur in ms
+#define MAX_NOTIFICATION_SIZE      4         // maximum size of a notification
+#define RESET_TIMEOUT              360       // number of milliseconds in which to complete link reset
+#define ACK_RESEND_DELAY           120       // number of ms between message re-transmissions if no ACK is received
+#define MAX_TX_TRIES               3         // maximum number of message send attempts before a tx packet is discarded
+#define MAX_IOCTL_TIMEOUT          500       // number of ms to wait for IOCTL to complete
+#define RX_PACKET_MEMORY           4         // number of most recent received sequence-length-crc sets to retain for repeated ACK's
+#define TX_UNACKED_WINDOW          4         // maximum number of packets to transmit without waiting for an ACK
+
+// mapping of ioctl's to SOM-MCU UART transactions
+typedef struct
+{
+     u8             msgType;       // message type, 0xFF for not implemented, 0xFE for any
+     u8             cmd;           // command to transmit to SOM, 0xFF for none
+     u8             cmdLen;        // length of data to send with the cmd, 0 for none, 0xFE for variable
+     u8             rsp;           // command to receive from SOM in response, 0xFF for none, 0xFE for any
+     u8             rspLen;        // length of data to received with the rsp, 0 for none, 0xFE for variable
+
+} SOM_MCU_ioctl_descriptor;
+
+// Functional areas of processing distinguished by the comm protocol
+typedef enum
+{
+     MSG_TYPE_INDICATORS = 1,      // buzzer and LED
+     MSG_TYPE_SYSTEM,              // overall state and behaviour of the MCU
+     MSG_TYPE_MOTOR,               // motor control
+     MSG_TYPE_BATTERY,             // battery control
+     MSG_TYPE_NONE
+
+} MessageType;
+
+//============================================================================================
+// Definitions for MSG_TYPE_INDICATORS
+//============================================================================================
+typedef enum
+{
+     PROTO_IND_CMD_PULSE_TRAIN = 1,     // 1 initiate a train of on/off pulses on LED and/or buzzer
+     PROTO_IND_CMD_LED_SET,             // 2 set LED to a specific colour or turn it off
+     PROTO_IND_CMD_BUZZER_SET,          // 3 set buzzer to a specific frequency or turn it off
+     PROTO_IND_CMD_LED_GET,             // 4 request to provide the current state of the LED
+     PROTO_IND_CMD_LED_STATUS,          // 5 response to IND_CMD_LED_GET
+     PROTO_IND_CMD_BUZZER_GET,          // 6 request to provide the current state of the buzzer
+     PROTO_IND_CMD_BUZZER_STATUS,       // 7 response to IND_CMD_BUZZER_GET
+     PROTO_IND_CMD_PULSE_TRAIN_GET,     // 8 request to provide current state of pulse train
+     PROTO_IND_CMD_PULSE_TRAIN_STATUS,  // 9 response to IND_CMD_PULSE_TRAIN_GET
+     PROTO_IND_CMD_PULSE_TRAIN_DEF_GET, // 10 request to provide current definition of a pulse train
+     PROTO_IND_CMD_PULSE_TRAIN_DEF,     // 11 response to IND_CMD_PULSE_TRAIN_DEF_GET
+     PROTO_IND_CMD_PULSE_TRAIN_DEF_SET, // 12 command to change definition of a pulse train
+
+} IndicatorCommand;
+
+//============================================================================================
+// Definitions for MSG_TYPE_SYSTEM
+//============================================================================================
+typedef enum
+{
+     PROTO_SYS_CMD_NOTIFY_BUTTON_UP = 1,          // 1 power button was pressed to wake up
+     PROTO_SYS_CMD_NOTIFY_CORRUPTION,             // 2 corruption of RAM or code bug detected
+     PROTO_SYS_CMD_NOTIFY_POWER_UP,               // 3 MCU is cold-starting
+     PROTO_SYS_CMD_SOM_IS_UP,                     // 4 message from SOM that is has started up
+     PROTO_SYS_CMD_NOTIFY_POWER_FAIL,             // 5 battery power is failing
+     PROTO_SYS_CMD_NOTIFY_SHUTDOWN,               // 6 shutting down
+     PROTO_SYS_CMD_SHUTDOWN,                      // 7 command from SOM to shutdown
+	PROTO_SYS_CMD_GET_FW_VER,                    // 8 command from SOM to get MCU's firmware version
+	PROTO_SYS_CMD_FW_NUMBERS,                    // 9 response to SYS_CMD_GET_FW_VER
+	PROTO_SYS_CMD_NOTIFY_WATCHDOG_RESET,         // 10 watchdog reset occurred
+	PROTO_SYS_CMD_GET_STATS1,                    // 11 get page 1 of statistics
+	PROTO_SYS_CMD_STATS1,                        // 12 response to SYS_CMD_GET_STATS1
+	PROTO_SYS_CMD_GET_STATS2,                    // 13 get page 2 of statistics
+	PROTO_SYS_CMD_STATS2,                        // 14 response to SYS_CMD_GET_STATS2
+	PROTO_SYS_CMD_GET_STATS3,                    // 15 get page 3 of statistics
+	PROTO_SYS_CMD_STATS3,                        // 16 response to SYS_CMD_GET_STATS3
+	PROTO_SYS_CMD_GET_STATS4,                    // 17 get page 4 of statistics
+	PROTO_SYS_CMD_STATS4,                        // 18 response to SYS_CMD_GET_STATS4
+	PROTO_SYS_CMD_ZAP_STATS,                     // 19 clear all statistics counters
+	PROTO_SYS_CMD_EPROM_PAGE_GET,                // 20 request to get EEPROM page contents
+	PROTO_SYS_CMD_EPROM_PAGE,                    // 21 response to SYS_CMD_EPROM_PAGE_GET
+	PROTO_SYS_CMD_EPROM_PAGE_SET,                // 22 request to set EEPROM page contents
+     PROTO_SYS_CMD_NOTIFY_INVALID_EPROM_PAGE,     // 23 invalid EEPROM page number specified in SYS_CMD_EPROM_PAGE_SET command
+	PROTO_SYS_CMD_EPROM_PAGE_ERASE,              // 24 request to erase EEPROM page contents
+	PROTO_SYS_CMD_STACK_SIZES_GET,               // 25 request to provide tasks' used stack sizes
+	PROTO_SYS_CMD_STACK_SIZES,                   // 26 response to SYS_CMD_STACK_SIZES_GET
+
+} SystemCommand;
+
+//============================================================================================
+// Definitions for MSG_TYPE_MOTOR
+//============================================================================================
+typedef enum
+{
+     PROTO_MOTOR_CMD_CURRENT_PROFILE = 1,              // 1 real time current current profile packet from MCU to SOM
+     PROTO_MOTOR_CMD_ADC_OFFSET_GET,                   // 2 request to provide ADC idle value
+     PROTO_MOTOR_CMD_ADC_OFFSET_VALUE,                 // 3 response to MOTOR_CMD_ADC_OFFSET_GET
+     PROTO_MOTOR_CMD_GOTO,                             // 4 move to home/to snap/up/down
+     PROTO_MOTOR_CMD_NOTIFY_GOTO_COMPLETE,             // 5 the above command complete
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_INSERTED,             // 6 cartridge has been inserted (switch closed)
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_EJECTED,              // 7 cartridge has been ejected (switch opened)
+     PROTO_MOTOR_CMD_NOTIFY_HOME_POSITION_REACHED,     // 8 home position hall effect sensor reached
+     PROTO_MOTOR_CMD_NOTIFY_HOME_POSITION_LEFT,        // 9 home position hall effect sensor left
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_POSITION_REACHED,     // 10 snap position hall effect sensor reached
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_POSITION_LEFT,        // 11 snap position hall effect sensor left
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_DOOR_UP,              // 12 the snap door is up (optical sensor)
+     PROTO_MOTOR_CMD_NOTIFY_SNAP_DOOR_DOWN,            // 13 the snap door is down (optical sensor)
+     PROTO_MOTOR_CMD_NOTIFY_MOTOR_STALL_DETECTED,      // 14 stall current detected
+     PROTO_MOTOR_CMD_SOM_CONTROL_BRAKE,                // 15 direct SOM control motor brake
+     PROTO_MOTOR_CMD_SOM_CONTROL_POWEROFF,             // 16 direct SOM control motor power off
+     PROTO_MOTOR_CMD_SOM_CONTROL_CCW,                  // 17 direct SOM control motor counter-clockwise
+     PROTO_MOTOR_CMD_SOM_CONTROL_CW,                   // 18 direct SOM control motor clockwise
+     PROTO_MOTOR_CMD_SOM_CONTROL_PWM,                  // 19 direct SOM control set PWM duty cycle and frequency
+     PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,        // 20 direct SOM control disable motor
+     PROTO_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,         // 21 direct SOM control enable motor
+     PROTO_MOTOR_CMD_SOM_CONTROL_ADC_OFF,              // 22 direct SOM control disable current profile transmission
+     PROTO_MOTOR_CMD_SOM_CONTROL_ADC_ON,               // 23 direct SOM control enable current profile transmission
+     PROTO_MOTOR_CMD_STALL_CURRENT_GET,                // 24 request to provide stall current threshold value
+     PROTO_MOTOR_CMD_STALL_CURRENT,                    // 25 response to MOTOR_CMD_STALL_CURRENT_GET
+     PROTO_MOTOR_CMD_STALL_CURRENT_SET,                // 26 command to set stall current threshold to a specific value
+     PROTO_MOTOR_CMD_ALL_PARMS_GET,                    // 27 request to provide of all motor parameters
+     PROTO_MOTOR_CMD_ALL_PARMS,                        // 28 response to MOTOR_CMD_ALL_PARMS_GET
+     PROTO_MOTOR_CMD_ALL_PARMS_SET,                    // 29 command to set all motor parameters to specific values
+     PROTO_MOTOR_CMD_STALL_SAMPLES_GET,                // 30 request to provide stall current minimum samples value
+     PROTO_MOTOR_CMD_STALL_SAMPLES,                    // 31 response to MOTOR_CMD_STALL_SAMPLES_GET
+     PROTO_MOTOR_CMD_STALL_SAMPLES_SET,                // 32 command to set stall current minimum samples to a specific value
+     PROTO_MOTOR_CMD_NO_STALL_CURRENT_GET,             // 33 request to provide no-stall current ADC threshold value
+     PROTO_MOTOR_CMD_NO_STALL_CURRENT,                 // 34 response to MOTOR_CMD_NO_STALL_CURRENT_GET
+     PROTO_MOTOR_CMD_NO_STALL_CURRENT_SET,             // 35 command to set no-stall current ADC threshold to a specific value
+     PROTO_MOTOR_CMD_NO_STALL_SAMPLES_GET,             // 36 request to provide no-stall current minimum samples value
+     PROTO_MOTOR_CMD_NO_STALL_SAMPLES,                 // 37 response to MOTOR_CMD_NO_STALL_SAMPLES_GET
+     PROTO_MOTOR_CMD_NO_STALL_SAMPLES_SET,             // 38 command to set no-stall current minimum samples to a specific value
+     PROTO_MOTOR_CMD_TIMEOUT_SNAP_GET,                 // 39 request to provide snap move timeout value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_SNAP,                     // 40 response to MOTOR_CMD_TIMEOUT_SNAP_GET
+     PROTO_MOTOR_CMD_TIMEOUT_SNAP_SET,                 // 41 command to set snap move timeout to a specific value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_HOME_GET,                 // 42 request to provide home move timeout value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_HOME,                     // 43 response to MOTOR_CMD_TIMEOUT_HOME_GET
+     PROTO_MOTOR_CMD_TIMEOUT_HOME_SET,                 // 44 command to set home move timeout to a specific value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_UP_GET,                   // 45 request to provide up move timeout value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_UP,                       // 46 response to MOTOR_CMD_TIMEOUT_UP_GET
+     PROTO_MOTOR_CMD_TIMEOUT_UP_SET,                   // 47 command to set up move timeout to a specific value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_DOWN_GET,                 // 48 request to provide down move timeout value (seconds)
+     PROTO_MOTOR_CMD_TIMEOUT_DOWN,                     // 49 response to MOTOR_CMD_TIMEOUT_DOWN_GET
+     PROTO_MOTOR_CMD_TIMEOUT_DOWN_SET,                 // 50 command to set down move timeout to a specific value (seconds)
+     PROTO_MOTOR_CMD_MAX_PWM_GET,                      // 51 request to provide full power PWM value (0-1023)
+     PROTO_MOTOR_CMD_MAX_PWM,                          // 52 response to MOTOR_CMD_MAX_PWM_GET
+     PROTO_MOTOR_CMD_MAX_PWM_SET,                      // 53 command to set full power PWM to a specific value (0-1023)
+     PROTO_MOTOR_CMD_FREQ_GET,                         // 54 request to provide PWM frequency value
+     PROTO_MOTOR_CMD_FREQ,                             // 55 response to MOTOR_CMD_FREQ_GET
+     PROTO_MOTOR_CMD_FREQ_SET,                         // 56 command to set PWM frequency to a specific value
+     PROTO_MOTOR_CMD_ACC_PROF_GET,                     // 57 request to provide acceleration profile number (0-5)
+     PROTO_MOTOR_CMD_ACC_PROF,                         // 58 response to MOTOR_CMD_ACC_PROF_GET
+     PROTO_MOTOR_CMD_ACC_PROF_SET,                     // 59 command to set acceleration profile to a specific number (0-5)
+     PROTO_MOTOR_CMD_ACC_STEP_GET,                     // 60 request to provide acceleration profile step value (ms)
+     PROTO_MOTOR_CMD_ACC_STEP,                         // 61 response to MOTOR_CMD_ACC_STEP_GET
+     PROTO_MOTOR_CMD_ACC_STEP_SET,                     // 62 command to set acceleration profile step to a specific value (ms)
+     PROTO_MOTOR_CMD_DEC_PROF_GET,                     // 63 request to provide deceleration profile number (0-5)
+     PROTO_MOTOR_CMD_DEC_PROF,                         // 64 response to MOTOR_CMD_DEC_PROF_GET
+     PROTO_MOTOR_CMD_DEC_PROF_SET,                     // 65 command to set deceleration profile to a specific number (0-5)
+     PROTO_MOTOR_CMD_DEC_STEP_GET,                     // 66 request to provide deceleration profile step value (ms)
+     PROTO_MOTOR_CMD_DEC_STEP,                         // 67 response to MOTOR_CMD_DEC_STEP_GET
+     PROTO_MOTOR_CMD_DEC_STEP_SET,                     // 68 command to set deceleration profile step to a specific value (ms)
+     PROTO_MOTOR_CMD_UP_DIR_GET,                       // 69 request to provide motor control setting for moving up (MotorDiection enum)
+     PROTO_MOTOR_CMD_UP_DIR,                           // 70 response to MOTOR_CMD_UP_DIR_GET
+     PROTO_MOTOR_CMD_UP_DIR_SET,                       // 71 command to set motor control setting for moving up to a specific value (MotorDiection enum)
+     PROTO_MOTOR_CMD_PROFILE_ARRAY_GET,                // 72 command to provide the 6-byte array of acceleration or deceleration profiles
+     PROTO_MOTOR_CMD_PROFILE_ARRAY,                    // 73 response to MOTOR_CMD_PROFILE_ARRAY_GET
+     PROTO_MOTOR_CMD_PROFILE_ARRAY_SET,                // 74 command to set the 6-byte array of acceleration or deceleration profiles
+     PROTO_MOTOR_CMD_ALL_SENSORS_GET,                  // 75 request to provide state of all sensors
+     PROTO_MOTOR_CMD_ALL_SENSORS,                      // 76 response to MOTOR_CMD_ALL_SENSORS_GET
+
+} MotorCommand;
+
+//============================================================================================
+// Definitions for MSG_TYPE_BATTERY
+//============================================================================================
+typedef enum
+{
+     PROTO_BATT_CMD_NOTIFY_CHARGER_IN = 1,   // 1 charger plugged in
+     PROTO_BATT_CMD_NOTIFY_CHARGER_OUT,      // 2 charger unplugged
+     PROTO_BATT_CMD_NOTIFY_100mA,            // 3 charging at 100 mA
+     PROTO_BATT_CMD_NOTIFY_500mA,            // 4 charging at 500 mA
+     PROTO_BATT_CMD_NOTIFY_1A,               // 5 charging at 1 A
+	PROTO_BATT_CMD_GET_STATUS,              // 6 request to get battery status
+	PROTO_BATT_CMD_STATUS,                  // 7 response to BATT_CMD_GET_STATUS
+     PROTO_BATT_CMD_NOTIFY_GG_ERROR,         // 8 gas gauge transaction resulted in error
+	PROTO_BATT_CMD_GET_GG_VERSION,          // 9 request to get gas gauge IC type and firmware version
+	PROTO_BATT_CMD_GG_VERSION,              // 10 response to BATT_CMD_GET_GG_VERSION
+
+// the following are no longer supported, the numbers are reserved for backward compatibility
+//	PROTO_BATT_CMD_GET_GG_DFI_CHECKSUM,      // 11 request to get gas gauge data flash check sum
+//	PROTO_BATT_CMD_GG_DFI_CHECKSUM,          // 12 response to BATT_CMD_GET_GG_CHECKSUM
+//	PROTO_BATT_CMD_GG_DFI_FLASH,             // 13 request to flash data flash "golden image" onto the gas gauge IC
+//	PROTO_BATT_CMD_NOTIFY_GG_DFI_FLASH_DONE, // 14 data flash "golden image" has been flashed onto the gas gauge IC
+//	PROTO_BATT_CMD_NOTIFY_GG_DFI_FLASH_ERROR,     // 15 error flashing data flash "golden image" onto the gas gauge IC
+
+	PROTO_BATT_CMD_FS_PKT = 16,             // 16 request to process a flashstream packet
+	PROTO_BATT_CMD_NOTIFY_FS_PKT_STATUS,    // 17 notification of success/failure in processing the last flashstream packet, also signals readiness for the next one
+	PROTO_BATT_CMD_OVERRIDE_CHARGE_RATE,    // 18 request to override battery charger rate
+     PROTO_BATT_CMD_NOTIFY_CHARGE_OFF,       // 19 not charging even though charger is plugged in (forced by BATT_CMD_OVERRIDE_CHARGE_RATE)
+
+} BatteryCommand;
+
+#pragma pack(push, 1)
+typedef struct      // MOTOR_CMD_CURRENT_PROFILE format
+{
+     u16  seqNum;                            // sequence number of this packet in the stream of current profile packets; starts with 1
+     u8   numSamples;                        // number of samples in this packet in bits 7-0, if bit 8 is set, this is the last packet in the profile
+#define PROF_NUM_SAMPLE_PAIRS 15             // number of sample pairs in one current profile packet
+     u8   data[PROF_NUM_SAMPLE_PAIRS][3];    // 2 12-bit samples are packed in 3 bytes
+
+} MotorCurProfCmd;
+#pragma pack(pop)
+
+// input packet parser states
+typedef enum   // the order of definitions in this enum is significant; if changed, bith rx and tx state machines must be changed
+{
+     RXTX_IDLE,          // the communications state machine is waiting to start deciphering a message
+     RXTX_MESSAGE_TYPE,  // message type
+     RXTX_SEQ,           // sequence Number
+     RXTX_DATA_SIZE,     // size of the packet's payload
+     RXTX_CMD,           // command of a particular message type
+     RXTX_DATA,          // data for the command
+     RXTX_CHKSUM1,       // first CRC-16 byte
+     RXTX_CHKSUM2,       // second CRC-16 byte
+
+} RxTxState;
+
+// hard error processing states
+typedef enum
+{
+     HARD_ERROR_NONE,              // all good
+     HARD_ERROR_PROCESSING,        // encountered a hard error
+	HARD_ERROR_TRANSMITTED,       // transmitted reset command
+     HARD_ERROR_FAILED,            // failed in trying to reset the link after hard error
+
+} ProtocolHardErrorState;
+
+// ESC and STX parsing states
+typedef enum
+{
+     ESC_PARSER_LOOK_FOR_ESC,      // passing bytes through; ESC_CHAR will be held
+     ESC_PARSER_ESC_FOUND,         // holding an ESC_CHAR in anticipation of the next byte
+     ESC_PARSER_SOLO_ESC,          // ESC_CHAR not followed by either ESC_CHAR or STX_CHAR
+
+} EscParserState;
+
+typedef enum
+{
+     TX_TYPE_NONE,       // transmitting reset command
+     TX_TYPE_RESET,      // transmitting reset command
+     TX_TYPE_ACK_RESET,  // transmitting an ACK to a reset command
+     TX_TYPE_ACK,        // transmitting an ACK to a command
+     TX_TYPE_COMMAND,    // transmitting a command
+
+} TxType;
+
+extern SOM_MCU_ioctl_descriptor ioctlDefinition[NUMBER_OF_SOM_IOCTLS];
+
+#endif    // SOM_MCU_PROTO_H
diff --git a/drivers/tty/mcu_comm/workArray.h b/drivers/tty/mcu_comm/workArray.h
index 5736c7a..ef07aca 100644
--- a/drivers/tty/mcu_comm/workArray.h
+++ b/drivers/tty/mcu_comm/workArray.h
@@ -1,84 +1,87 @@
-#ifndef SOM_MCU_WORK_ARRAY_H
-#define SOM_MCU_WORK_ARRAY_H
-
-#include <linux/types.h>
-#include <linux/completion.h>
-#include <linux/timer.h>
-#include <linux/tty.h>
-#include <asm/atomic.h>
-#include <linux/idexxmcu_ioctl.h>
-
-#define MAX_DATA_LENGTH            49        // maximum allowed number of data characters in a packet
-
-typedef enum
-{
-     RESULT_SUCCESS,
-     RESULT_NO_ACK,                // no ACK was received, this will also cause a link reset and the notification about it
-     RESULT_TIMEOUT,               // response from MCU was not received in the prescribed time
-     RESULT_ABORTED,               // transaction was aborted by link reset or signal
-     RESULT_NO_MEM,                // output buffer was not large enough
-
-} ResultCode;
-
-typedef enum                       // order of entries in this enum is significant
-{
-     RS_IDLE,                      // no consumer for this ioctl
-     RS_SUBMITTED,                 // ready for work
-     RS_ACCEPTED,                  // accepted for transmission
-     RS_TRANSMITTED,               // has been transmitted
-     RS_ACKED,                     // has been acknowledged
-
-} RequestState;
-
-typedef struct
-{
-     // variables used by the ioctl handler
-     atomic_t            onlyOneThread;      // mutex to prevent multi-threading on an ioctl
-     void                *input;   // user space pointer to the data to be transmitted to the MCU, if any; does not need to be initialized if not used
-     void                *output;  // user space pointer to the data to be received from the MCU, if any; does not need to be initialized if not used
-     u32                 outSize;  // size of the buffer pointed to by output; does not need to be initialized if not used
-     ResultCode          retValue; // completion status; does not need to be initialized; valid only after return from SOM_MCU_SubmitToProto
-
-     // when there is a new ioctl to be performed, do the following in the order described:
-     //
-     //   determine the index "ind" into SOM_MCU_workRequest for the ioctl
-     //
-     //   prevent more than one thread from using the ioctl by:
-     //        if (atomic_cmpxchg(&SOMC_MCU_workRequest[ind].onlyOneThread, 0, 1))
-     //        {
-     //             return a "busy" error to the caller
-     //        }
-     //
-     //   initialize input, output, and outSize of the SOM_MCU_workRequest element (if needed)
-     //
-     //   issue the processing function call:
-     //        SOM_MCU_SubmitToProto(ind);
-     //   it will return when the ioctl has been processed -- user space output buffer has been filled and ResultCode set.
-     //
-     //   at the very end when no data in SOMC_MCU_workRequest[ind] is needed any more, reset the mutex:
-     //        atomic_set(&SOM_MCU_workRequest[ind].onlyOneThread, 0);
-   
-     // variables used by the protocol handler
-#pragma pack(4)
-     u8                  inBuffer[MAX_DATA_LENGTH - 1];     // buffer for input data
-     u8                  outBuffer[MAX_DATA_LENGTH - 1];    // buffer for output data
-     struct timer_list ioctlTimeout;                        // holds the time when this ioctl will time out waiting for MCU response
-     struct timer_list ackTimeout;                          // holds the time when this ioctl will time out waiting for ACK
-     u8                  reXmitCnt;                         // ACK re-transmit counter
-     u8                  seq;                               // sequence number used to transmit this packet or 0 if it has not yet been transmitted
-     struct completion   workIndicator;                     // used to indicate presence/absence of ioctl consumer
-     RequestState        state;                             // processing state of this ioctl
-
-} WorkElement;
-
-// all the ioctl's are performed via this array indexed by a value of the SOM_ioctl_cmd type (ioctl_desc.h); it is initialized during module startup
-extern volatile WorkElement SOM_MCU_workRequest[NUMBER_OF_SOM_IOCTLS];
-
-int SOM_MCU_open(struct tty_struct *ttyPtr);
-void	SOM_MCU_close(struct tty_struct *);
-int SOM_MCU_hangup(struct tty_struct *tty);
-void	SOM_MCU_receive_buf(struct tty_struct *, const unsigned char *cp, char *fp, int count);
-void	SOM_MCU_write_wakeup(struct tty_struct *);
-void SOM_MCU_SubmitToProto(int ind); 
-
-#endif    // SOM_MCU_WORK_ARRAY_H
+#ifndef SOM_MCU_WORK_ARRAY_H
+#define SOM_MCU_WORK_ARRAY_H
+
+static const char idexxmcu_workarray_h_version[] = "0.2.1-m";
+
+#include <linux/types.h>
+#include <linux/completion.h>
+#include <linux/timer.h>
+#include <linux/tty.h>
+#include <asm/atomic.h>
+#include <linux/idexxmcu_ioctl.h>
+
+typedef enum
+{
+	RESULT_SUCCESS,
+	RESULT_NO_ACK,                // no ACK was received, this will also cause a link reset and the notification about it
+	RESULT_TIMEOUT,               // response from MCU was not received in the prescribed time
+	RESULT_ABORTED,               // transaction was aborted by link reset or signal
+	RESULT_NO_MEM,                // output buffer was not large enough
+	RESULT_NO_THREAD,             // no thread waiting for current profile
+
+} ResultCode;
+
+typedef enum                       // order of entries in this enum is significant
+{
+	RS_IDLE,                      // no consumer for this ioctl
+	RS_SUBMITTED,                 // ready for work
+	RS_ACCEPTED,                  // accepted for transmission
+	RS_TRANSMITTED,               // has been transmitted
+	RS_ACKED,                     // has been acknowledged
+
+} RequestState;
+
+typedef struct
+{
+	// variables used by the ioctl handler
+	atomic_t            onlyOneThread;      // mutex to prevent multi-threading on an ioctl
+	void                *input;   // user space pointer to the data to be transmitted to the MCU, if any; does not need to be initialized if not used
+	void                *output;  // user space pointer to the data to be received from the MCU, if any; does not need to be initialized if not used
+	u32                 inSize;   // size of the buffer pointed to by input
+	u32                 outSize;  // size of the buffer pointed to by output; does not need to be initialized if not used
+	ResultCode          retValue; // completion status; does not need to be initialized; valid only after return from SOM_MCU_SubmitToProto
+
+	// when there is a new ioctl to be performed, do the following in the order described:
+	//
+	//   determine the index "ind" into SOM_MCU_workRequest for the ioctl
+	//
+	//   prevent more than one thread from using the ioctl by:
+	//        if (atomic_cmpxchg(&SOMC_MCU_workRequest[ind].onlyOneThread, 0, 1))
+	//        {
+	//             return a "busy" error to the caller
+	//        }
+	//
+	//   initialize input, output, and outSize of the SOM_MCU_workRequest element (if needed)
+	//
+	//   issue the processing function call:
+	//        SOM_MCU_SubmitToProto(ind);
+	//   it will return when the ioctl has been processed -- user space output buffer has been filled and ResultCode set.
+	//
+	//   at the very end when no data in SOMC_MCU_workRequest[ind] is needed any more, reset the mutex:
+	//        atomic_set(&SOM_MCU_workRequest[ind].onlyOneThread, 0);
+
+	// variables used by the protocol handler
+#pragma pack(push, 4)
+	u8                  inBuffer[MAX_DATA_LENGTH - 1];     // buffer for input data
+	u8                  outBuffer[MAX_DATA_LENGTH - 1];    // buffer for output data
+#pragma pack(pop)
+	struct timer_list ioctlTimeout;                        // holds the time when this ioctl will time out waiting for MCU response
+	struct timer_list ackTimeout;                          // holds the time when this ioctl will time out waiting for ACK
+	u8                  reXmitCnt;                         // ACK re-transmit counter
+	u8                  seq;                               // sequence number used to transmit this packet or 0 if it has not yet been transmitted
+	struct completion   workIndicator;                     // used to indicate presence/absence of ioctl consumer
+	RequestState        state;                             // processing state of this ioctl
+
+} WorkElement;
+
+// all the ioctl's are performed via this array indexed by a value of the SOM_ioctl_cmd type (ioctl_desc.h); it is initialized during module startup
+extern volatile WorkElement SOM_MCU_workRequest[NUMBER_OF_SOM_IOCTLS];
+
+int SOM_MCU_open(struct tty_struct *ttyPtr);
+void	SOM_MCU_close(struct tty_struct *);
+int SOM_MCU_hangup(struct tty_struct *tty);
+void	SOM_MCU_receive_buf(struct tty_struct *, const unsigned char *cp, char *fp, int count);
+void	SOM_MCU_write_wakeup(struct tty_struct *);
+void SOM_MCU_SubmitToProto(int ind);
+
+#endif    // SOM_MCU_WORK_ARRAY_H
diff --git a/drivers/video/omap2/displays/panel-himax-hx8369a02.c b/drivers/video/omap2/displays/panel-himax-hx8369a02.c
index 4e97e43..3f2748c 100644
--- a/drivers/video/omap2/displays/panel-himax-hx8369a02.c
+++ b/drivers/video/omap2/displays/panel-himax-hx8369a02.c
@@ -2,7 +2,7 @@
  * \file	panel-himax-hx8369a02.c
  *
  * \brief LCD panel driver for Truly TFT480800 TFT display panel 
- * 	with Himax hx8369-a02 display controller. 
+ * 	with Himax hx8369-a02 and hx8363 display controller. 
  *
  * \author Author: Michael Tsukernik <mike.tsukernik@logicpd.com>
  *
@@ -22,11 +22,16 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
-
+#include <linux/gpio.h>
 #include <video/omapdss.h>
 #include <plat/board-omap3logic-display.h>
 
+#define LCD_PANEL_HIMAX_HX8369	1
+#define LCD_PANEL_HIMAX_HX8363	2
+#define LCD_PANEL_HIMAX_UNKNOWN	-1
+#define LCD_PANEL_YET_TO_DETECT	0
 static struct spi_device	*spidev = NULL;
+static int econ_hx8369_read_reg(u8 reg, u8 n_rx_bytes, u8 *read_buffer,u8 is_reg_command);
 
 struct omap3logic_panel omap3logic_default_panel = {
         .name = "himax_hx8369",
@@ -173,6 +178,154 @@ static int hx8369_write_reg(u8 reg, u8 num, ...)
 }
 
 /*******************************************************************************/
+/* !
+
+  \brief A utility function to read single/ sequence of register(s)
+  over the SPI bus from the LCD panel.
+
+  \b Purpose:
+  Reading register data from lcd panel is required for operations like detecting panel,
+  revision number, etc..
+  This function takes that data and formats them into SPI messages appropriate for the LCD
+  panel.
+
+  \param [in] reg
+  This value indicates which register from which read operation to be done.
+
+  \param [in] n_rx_bytes
+  This value indicates the number of values to be read from the register.
+
+  \param [out] read_buffer
+  A buffer of 'num' parameter size, to which read data will be stored
+ 
+  \param [in] is_reg_command
+  This value indicates whether 'reg' parameter is a register address or direct command
+
+  \return This function returns 0 on success.  Upon failure, the function returns
+  errno related to spi_sync().
+*/
+/*******************************************************************************/
+
+static int econ_hx8369_read_reg(u8 reg, u8 n_rx_bytes, u8 *read_buffer,u8 is_reg_command)
+{
+	u8 len=0;
+	int ret=0,i=0;
+        struct spi_transfer value_xfer[100];
+	u16 *spi_tx_buf = (u16 *)kzalloc(100,GFP_KERNEL);
+	if(!spi_tx_buf)
+	{
+		printk("FUNC %s LINE %d: Failed to allocate memory for spi_tx_buf \n",__FUNCTION__,__LINE__);
+		return -ENOMEM;
+	}
+	u8 *spi_rx_buf = (u8 *)kzalloc(100,GFP_KERNEL);
+	if(!spi_rx_buf)
+	{
+		printk("FUNC %s LINE %d: Failed to allocate memory for spi_rx_buf \n",__FUNCTION__,__LINE__);
+		if(spi_tx_buf) kfree(spi_tx_buf);
+		return -ENOMEM;
+	}
+	struct spi_transfer t = {
+	.rx_buf = spi_rx_buf,
+	.len = 2,
+	.cs_change = 0,
+	.speed_hz = 50000,
+	.bits_per_word = 9,
+	};
+ 
+
+	struct spi_message m;
+	spi_message_init(&m);
+	memset(value_xfer,0,sizeof(value_xfer));
+
+	if(!is_reg_command)
+	{
+		// Send Command
+		spi_tx_buf[0] = 0xFE; // SET SPI READ INDEX
+ 	        t.tx_buf = spi_tx_buf;
+		t.len = 2;
+		t.cs_change = 0,
+		t.bits_per_word = 9;
+		t.speed_hz = 50000;
+		t.rx_buf = NULL; //spi_rx_buf;
+	        spi_message_add_tail(&t, &m);
+		len=t.len;
+
+		// Send Data
+		spi_tx_buf[1] = reg | 0x100; // Register Address
+		value_xfer[0].len = 2;
+		value_xfer[0].cs_change = 0,
+		value_xfer[0].bits_per_word = 9;
+		value_xfer[0].tx_buf = spi_tx_buf + 1;
+		value_xfer[0].rx_buf = NULL; //spi_rx_buf;
+		value_xfer[0].speed_hz = 50000;
+		spi_message_add_tail(&value_xfer[0], &m);
+		len += value_xfer[0].len;
+
+		// Send Command
+		spi_tx_buf[2] = 0xFF; // SPIREAD
+		value_xfer[1].len = 2;
+		value_xfer[1].cs_change = 0,
+		value_xfer[1].bits_per_word = 9;
+		value_xfer[1].tx_buf = spi_tx_buf + 2;
+		value_xfer[1].rx_buf = NULL;
+		value_xfer[1].speed_hz = 50000;
+		spi_message_add_tail(&value_xfer[1], &m);
+		len += value_xfer[1].len;
+
+		// Read Data
+		value_xfer[2].len = n_rx_bytes;
+		value_xfer[2].cs_change = 0,
+		value_xfer[2].bits_per_word = 8;
+		value_xfer[2].tx_buf = NULL;
+		value_xfer[2].rx_buf = spi_rx_buf;
+		value_xfer[2].speed_hz = 50000;
+		spi_message_add_tail(&value_xfer[2], &m);
+		len += value_xfer[2].len;
+
+	}
+	else
+	{
+		// Send Command
+		spi_tx_buf[0] = reg;
+	        t.tx_buf = spi_tx_buf;
+		t.len = 2;
+		t.bits_per_word = 9;
+		t.speed_hz = 50000;
+		t.cs_change = 0,
+		t.rx_buf = NULL;
+	        spi_message_add_tail(&t, &m);
+		len=t.len;
+
+		// Read Data
+		value_xfer[0].len = n_rx_bytes;
+		value_xfer[0].cs_change = 0,
+		value_xfer[0].bits_per_word = 8;
+		value_xfer[0].tx_buf = NULL;
+		value_xfer[0].rx_buf = spi_rx_buf;
+		value_xfer[0].speed_hz = 50000;
+		spi_message_add_tail(&value_xfer[0], &m);
+		len += value_xfer[0].len;
+	}
+
+	ret = spi_sync(spidev, &m);
+	if (ret)
+		dev_err(&spidev->dev, "spi transfer failed: ret = %d\n", ret);
+
+	for(i=0;i<len;i++)
+	{
+		printk("FUNC %s LINE %d: spi_tx_buf[%d] = 0x%04X spi_rx_buf[%d] = 0x%02X \n",__FUNCTION__,__LINE__,i,spi_tx_buf[i],i,spi_rx_buf[i]);
+	}
+ 
+	memcpy(read_buffer,spi_rx_buf,n_rx_bytes);
+	kfree(spi_tx_buf);
+	kfree(spi_rx_buf);
+	spi_tx_buf=NULL;
+	spi_rx_buf=NULL;
+	return ret;
+
+}
+
+/*******************************************************************************/
 /*!
   \brief This function is called by DSS before the enable() function.
 
@@ -191,12 +344,68 @@ static int hx8369_write_reg(u8 reg, u8 num, ...)
 static int hx8369_panel_pre_enable(struct omap_dss_device *dssdev)
 {
         int r = 0;
+#ifdef CONFIG_WALNUT_RETAIN_BOOT_LOGO
+	static int enable_count=0;
+#endif
 
         if (dssdev->platform_pre_enable)
                 r = dssdev->platform_pre_enable(dssdev);
 
         return r;
 }
+
+/*******************************************************************************/
+/* 
+ * Read IDs from LCD module
+ * This function returns one of the followings
+ *  LCD_PANEL_HIMAX_HX8363 when LCD module HX8363 is interfaced to uP
+ *  LCD_PANEL_HIMAX_HX8369 when LCD module HX8369 is interfaced to uP
+ *  LCD_PANEL_HIMAX_UNKNOWN when neither LCD module HX8363 nor HX8369 is interfaced to uP
+ */
+/*******************************************************************************/
+
+int detect_lcd_panel(void)
+{
+	int i=0;
+	int r=0;
+	u8 reg_read_buf[2048];
+
+	// Send Command SETEXT with parameters for LCD module HX8363
+	r = hx8369_write_reg(0xb9,3,0xff,0x83,0x69); 
+        if (r) return r;
+	// Clear read buffer
+	memset(reg_read_buf,128,0x00);
+	// Read IDs from regsiter 0xB9
+	econ_hx8369_read_reg(0xB9,3,reg_read_buf,0);
+	if(reg_read_buf[2]==0x69)
+	{
+		printk("Detected LCD panel is HX8369 \n");
+		return LCD_PANEL_HIMAX_HX8369;
+	}
+	else
+	{
+		// Send Command SETEXT with parameters for LCD module HX8363
+		r = hx8369_write_reg(0xb9,3,0xff,0x83,0x63); 
+	        if (r) return r;
+		// Clear read buffer
+		memset(reg_read_buf,128,0x00);
+		// Read IDs from regsiter 0xB9
+		econ_hx8369_read_reg(0xB9,3,reg_read_buf,0);
+		if(reg_read_buf[2]==0x63)
+		{
+			printk("Detected LCD panel is HX8363 \n");
+			return LCD_PANEL_HIMAX_HX8363;
+		}
+		else
+		{
+			printk("Detected LCD panel is UNKNOWN \n");
+			return LCD_PANEL_HIMAX_UNKNOWN;
+		}
+	}
+
+	return 0;
+}
+
 /*******************************************************************************/
 /*!
   \brief This function is called by DSS to enable the LCD panel.
@@ -214,6 +423,11 @@ static int hx8369_panel_pre_enable(struct omap_dss_device *dssdev)
 static int hx8369_panel_enable(struct omap_dss_device *dssdev)
 {
         int r = 0;
+	int i = 0;
+	int panel=LCD_PANEL_YET_TO_DETECT;
+#ifdef CONFIG_WALNUT_RETAIN_BOOT_LOGO
+	static int enable_count=0;
+#endif
 
         if (spidev == NULL){
                 pr_err("%s: SPI interface unconfigured\n", __FUNCTION__);
@@ -227,6 +441,25 @@ static int hx8369_panel_enable(struct omap_dss_device *dssdev)
 	    r = omapdss_dpi_display_enable(dssdev);
 	    if (r)
                 return r;
+
+#ifdef CONFIG_WALNUT_RETAIN_BOOT_LOGO
+	if(enable_count==0)
+	{
+		enable_count++;
+        	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
+		pr_info("No need to configure himax at first time only . Because It is already configured in xboot. \n");
+		return 0;
+	}
+	else
+	{
+		enable_count++;
+		if(panel==LCD_PANEL_YET_TO_DETECT)
+		{
+			printk("enable_count is %d \n",enable_count);
+			panel = detect_lcd_panel();
+		}
+	}
+#endif
         
         pr_info("himax_hx8369: panel_enable: 0x%08x\n", (unsigned int)spidev);
         /* wait couple of vsyncs until enabling the LCD */
@@ -235,108 +468,232 @@ static int hx8369_panel_enable(struct omap_dss_device *dssdev)
         if (dssdev->platform_enable)
                 r = dssdev->platform_enable(dssdev);
 
-        /* Panel init sequence taken from page 23 of the 
-	 * Truly TFT480800-63-E application note version 0.1 Feb 9, 2012
-	*/
-	// Send SETEXTC command
-        r = hx8369_write_reg(0xb9,3,0xff,0x83,0x69); 
-        if (r) return r;
-	// Set Power
-        r = hx8369_write_reg(0xB1,19, 
-			     0x85, 0x00, 0x34, 0x07, 0x00, 0x0F, 0x0F, 0x2A,
-			     0x32, 0x3F, 0x3F,
-      	//update VBIAS
-			     0x01, 0x3A, 0x01, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6);
-        if (r) return r;
-  
-
-	// SET Display  480x800
-	r = hx8369_write_reg(0xB2, 15, 
-			     0x00, 0x28, 0x05, 0x05, 0x70, 0x00, 0xFF, 0x00, 
-			     0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x01); 
-        if (r) return r;
-
-	/* SETRGBIF DPL:0 HSPL:0 VSPL:0 EPL:1 */
-	r = hx8369_write_reg(0xb3,1,0x1); 
-	if (r) return r;
+	switch(panel)
+	{
+
+		case LCD_PANEL_HIMAX_HX8369:
+		{
+        		/* Panel init sequence taken from page 23 of the 
+			 * Truly TFT480800-63-E application note version 0.1 Feb 9, 2012
+			*/
+			printk("panel is LCD_PANEL_HIMAX_HX8369 \n");
+			// Send SETEXTC command
+		        r = hx8369_write_reg(0xb9,3,0xff,0x83,0x69); 
+        		if (r) return r;
+			// Set Power
+        		r = hx8369_write_reg(0xB1,19, 
+					     0x85, 0x00, 0x34, 0x07, 0x00, 0x0F, 0x0F, 0x2A,
+					     0x32, 0x3F, 0x3F,
+		      	//update VBIAS
+				     0x01, 0x3A, 0x01, 0xE6, 0xE6, 0xE6, 0xE6, 0xE6);
+        		if (r) return r;
+
+		 	//Sleep Out	
+			r = hx8369_write_reg(0x11,0);
+	        	if (r) return r;
+
+			//Delay for 125milli seconds
+			for(i=0;i<125;i++)
+			{
+				udelay((1000));
+			}
+ 
+
+			// SET Display  480x800
+			r = hx8369_write_reg(0xB2, 15, 
+					     0x00, 0x28, 0x05, 0x05, 0x70, 0x00, 0xFF, 0x00, 
+					     0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x01); 
+	        	if (r) return r;
+
+			/* SETRGBIF DPL:0 HSPL:0 VSPL:0 EPL:1 */
+			r = hx8369_write_reg(0xb3,1,0x1); 
+			if (r) return r;
 	
-	// SETCYC
-	r = hx8369_write_reg(0xB4,5, 
-			     0x00, 0x18, 0x80, 0x06, 0x02);  
-        if (r) return r;
-
-	// SETVCOM
-	r = hx8369_write_reg(0xB6, 2, 0x42, 0x42);  
-        if (r) return r;
-
-	//SETGIP
-	r = hx8369_write_reg(0xD5, 26, 
-			     0x00, 0x04, 0x03, 0x00, 0x01, 0x05, 0x28, 0x70, 
-			     0x01, 0x03, 0x00, 0x00, 0x40, 0x06, 0x51, 0x07, 
-			     0x00, 0x00, 0x41, 0x06, 0x50, 0x07, 0x07, 0x0F, 
-			     0x04, 0x00);  
-        if (r) return r;
+			// SETCYC
+			r = hx8369_write_reg(0xB4,5, 
+					     0x00, 0x18, 0x80, 0x06, 0x02);  
+		        if (r) return r;
+	
+			// SETVCOM
+			r = hx8369_write_reg(0xB6, 2, 0x42, 0x42);  
+	        	if (r) return r;
+	
+			//SETGIP
+			r = hx8369_write_reg(0xD5, 26, 
+					     0x00, 0x04, 0x03, 0x00, 0x01, 0x05, 0x28, 0x70, 
+					     0x01, 0x03, 0x00, 0x00, 0x40, 0x06, 0x51, 0x07, 
+					     0x00, 0x00, 0x41, 0x06, 0x50, 0x07, 0x07, 0x0F, 
+					     0x04, 0x00);  
+        		if (r) return r;
       
-	// SETGAMMA - Gamma2.2 
-	r = hx8369_write_reg(0xE0, 34, 
-			     0x00, 0x13, 0x19, 0x38, 0x3D, 0x3F, 0x28, 0x46, 
-			     0x07, 0x0D, 0x0E, 0x12, 0x15, 0x12, 0x14, 0x0F, 
-			     0x17, 0x00, 0x13, 0x19, 0x38, 0x3D, 0x3F, 0x28, 
-			     0x46, 0x07, 0x0D, 0x0E, 0x12, 0x15, 0x12, 0x14, 
-			     0x0F, 0x17); 
-        if (r) return r;
-
-	msleep(10);
-
-	// SETDGCLUT
-        r = hx8369_write_reg(0xC1, 127, 0x01,
-			     //R
-			     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
-			     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
-			     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
-			     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
-			     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
-			     0x75, 0x00,
-			     //G
-			     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
-			     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
-			     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
-			     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
-			     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
-			     0x75, 0x00,
-			     //B
-			     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
-			     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
-			     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
-			     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
-			     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
-			     0x75, 0x00); 
-
-	msleep(10);
-
-	//Set_tear_on
-	r = hx8369_write_reg(0x35, 1, 0x00);
-        if (r) return r;
+			// SETGAMMA - Gamma2.2 
+			r = hx8369_write_reg(0xE0, 34, 
+					     0x00, 0x13, 0x19, 0x38, 0x3D, 0x3F, 0x28, 0x46, 
+					     0x07, 0x0D, 0x0E, 0x12, 0x15, 0x12, 0x14, 0x0F, 
+					     0x17, 0x00, 0x13, 0x19, 0x38, 0x3D, 0x3F, 0x28, 
+					     0x46, 0x07, 0x0D, 0x0E, 0x12, 0x15, 0x12, 0x14, 
+					     0x0F, 0x17); 
+        		if (r) return r;
+
+			msleep(10);
 	
-	// Set_pixel_format
-	r = hx8369_write_reg(0x3A, 1, 0x77);   
-        if (r) return r;
+			// SETDGCLUT
+	        	r = hx8369_write_reg(0xC1, 127, 0x01,
+					     //R
+					     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
+					     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
+					     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
+					     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
+					     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
+					     0x75, 0x00,
+					     //G
+					     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
+					     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
+					     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
+					     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
+					     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
+					     0x75, 0x00,
+					     //B
+					     0x04, 0x13, 0x1a, 0x20, 0x27, 0x2c, 0x32, 0x36,
+					     0x3f, 0x47, 0x50, 0x59, 0x60, 0x68, 0x71, 0x7B,
+					     0x82, 0x89, 0x91, 0x98, 0xA0, 0xA8, 0xB0, 0xB8,
+					     0xC1, 0xC9, 0xD0, 0xD7, 0xE0, 0xE7, 0xEF, 0xF7,
+					     0xFE, 0xCF, 0x52, 0x34, 0xF8, 0x51, 0xF5, 0x9D,
+					     0x75, 0x00); 
+
+			msleep(10);
+
+			//Set_tear_on
+			r = hx8369_write_reg(0x35, 1, 0x00);
+	        	if (r) return r;
+		
+			// Set_pixel_format
+			r = hx8369_write_reg(0x3A, 1, 0x77);   
+		        if (r) return r;
 
-	//Exit_sleep_mode
-	r = hx8369_write_reg(0x11, 0);
-        if (r) return r;
+			//Exit_sleep_mode
+			r = hx8369_write_reg(0x11, 0);
+        		if (r) return r;
 	
-	msleep(120);
+			udelay(1000);
 	
-	//Set_display_on
-	r = hx8369_write_reg(0x29,0);  
-        if (r) return r;
-
-	//Write_memory_start
-	r = hx8369_write_reg(0x2C,0); 
-        if (r) return r;
-
-	msleep(200);
+			//Set_display_on
+			r = hx8369_write_reg(0x29,0);  
+	        	if (r) return r;
+
+			//Write_memory_start
+			r = hx8369_write_reg(0x2C,0); 
+        		if (r) return r;
+
+			udelay(1000);
+		} // LCD_PANEL_HIMAX_HX8369
+		break;
+		case LCD_PANEL_HIMAX_HX8363:
+		{
+			/* LCD Init Sequence as mentioned in the Truly LCD MODULE Application Note Version:0.3  2014-01-24 
+			* (TDO-WVGA0347F00029-E Application Note V0.3.doc)
+ 			*/
+			printk("panel is LCD_PANEL_HIMAX_HX8363 \n");
+			// Send SETEXTC command
+			r = hx8369_write_reg(0xb9,3,0xff,0x83,0x63); 
+		        if (r) return r;
+	
+			// Set Power
+			r = hx8369_write_reg(0xB1,12, 
+					0x81, 0x32, 0x08, 0x33, 0x01, 0x13, 0x0D, 0x0D,
+					0x12, 0x16, 0x1E,0x1E);
+		        if (r) return r;
+	
+		
+			//Memory Access Control
+			r = hx8369_write_reg(0x36,1,0x02);
+		        if (r) return r;
+
+			// COLMOD
+			r = hx8369_write_reg(0x3A,1,0x70);
+		        if (r) return r;
+
+
+			//Set_RGBIF
+			r = hx8369_write_reg(0xB3,1,0x01);
+		        if (r) return r;
+
+
+			//Set_CYC CPT
+			r = hx8369_write_reg(0xB4,11,0x08,0x03,0xe0,0x30,0x01,0x12,0x64,0x01,0xff,0x00,0x00);
+		        if (r) return r;
+
+
+			//Set_VCOM
+			r = hx8369_write_reg(0xB6,1,0x10);
+		        if (r) return r;
+
+
+			//Set_Panel
+			r = hx8369_write_reg(0xCC,1,0x03);
+		        if (r) return r;
+
+			//Delay for 5milli seconds
+			mdelay(5);
+
+			//Gamma 2.2 
+			r = hx8369_write_reg(0xE0,30,
+						0x00,0x9E,0x63,0x72,0x36,0x3F,0x25,0xD6,0x0C,0x93,
+						0x58,0x15,0x78,0xBF,0x19,0x00,0x9E,0x63,0x72,0x36,
+						0x3F,0x25,0xD6,0x0C,0x93,0x58,0x15,0x78,0xBF,0x19);
+		        if (r) return r;
+
+			//Delay for 5milli seconds
+			mdelay(5);
+
+			//DGC
+			r = hx8369_write_reg(0xC1,127,0x01,
+					0x06,0x0D,0x1E,0x2F,0x3F,0x51,0x60,0x71,0x80,0x8B,
+					0x95,0x9F,0xA8,0xB1,0xBD,0xC8,0xCE,0xD5,0xDB,0xE1,
+					0xE4,0xE7,0xEB,0xEE,0xF0,0xF2,0xF4,0xF7,0xF8,0xFA,
+					0xFC,0xFD,0xFF,0xB1,0xDE,0xAE,0x90,0xDB,0x20,0xFC,
+					0xA2,0x02,
+				
+					0x06,0x0D,0x1E,0x2F,0x3F,0x51,0x60,0x71,0x80,0x8B,
+					0x95,0x9F,0xA8,0xB1,0xBD,0xC8,0xCE,0xD5,0xDB,0xE1,
+					0xE4,0xE7,0xEB,0xEE,0xF0,0xF2,0xF4,0xF7,0xF8,0xFA,
+					0xFC,0xFD,0xFF,0xB1,0xDE,0xAE,0x90,0xDB,0x20,0xFC,
+					0xA2,0x02,
+			
+					0x06,0x0D,0x1E,0x2F,0x3F,0x51,0x60,0x71,0x80,0x8B,
+					0x95,0x9F,0xA8,0xB1,0xBD,0xC8,0xCE,0xD5,0xDB,0xE1,
+					0xE4,0xE7,0xEB,0xEE,0xF0,0xF2,0xF4,0xF7,0xF8,0xFA,
+					0xFC,0xFD,0xFF,0xB1,0xDE,0xAE,0x90,0xDB,0x20,0xFC,
+					0xA2,0x02);
+	        	if (r) return r;
+
+
+			//Delay for 5milli seconds
+			mdelay(5);
+		
+			//Sleep Out	
+			r = hx8369_write_reg(0x11,0);
+		        if (r) return r;
+
+			//Delay for 125milli seconds
+			for(i=0;i<125;i++)
+			{
+				udelay((1000));
+			}
+
+			//Set_Panel
+			r = hx8369_write_reg(0x29,0);
+	        	if (r) return r;
+			udelay(1000);
+		} // LCD_PANEL_HIMAX_HX8363
+		break;
+		default:
+		case LCD_PANEL_HIMAX_UNKNOWN:
+		{
+			// Do nothing here
+		}
+		break;
+	} // end of switch case for panel
 
         dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
@@ -360,19 +717,21 @@ static int hx8369_panel_enable(struct omap_dss_device *dssdev)
 static void hx8369_panel_disable(struct omap_dss_device *dssdev)
 {
         pr_info("himax_hx8369: panel_disable: 0x%08x\n", (unsigned int)spidev);
-
+	
         if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)
                 return;
 
         hx8369_write_reg(0x10, 0);
 	//Add use internal oscillator
         hx8369_write_reg(0xC1, 1, 0x02);
-	msleep(200);
+	//msleep(200);
+	udelay(1000);
 	//Add use internal oscillator
         hx8369_write_reg(0xC1, 1, 0x01);
 	//LcdEnvidOnOff(0);
 
-        msleep(150);
+        //msleep(150);
+	udelay(1000);
 
         if (dssdev->platform_disable)
                 dssdev->platform_disable(dssdev);
diff --git a/include/linux/idexxmcu_ioctl.h b/include/linux/idexxmcu_ioctl.h
index 73e20b7..3eeb2fb 100644
--- a/include/linux/idexxmcu_ioctl.h
+++ b/include/linux/idexxmcu_ioctl.h
@@ -1,413 +1,858 @@
-#ifndef SOM_MCU_IOCTL_DESC_H
-#define SOM_MCU_IOCTL_DESC_H
-
-#ifndef __KERNEL__
-typedef unsigned char u8;
-typedef unsigned short u16;
-typedef unsigned int u32;
-typedef unsigned long u64;
-#endif
-
-#define  IDEXXMCU_PROTO_MAGIC  0x83
-
-typedef enum
-{
-     // the special ioctl to for all notifications, must be the first in this enum
-     NOTIFICATION_CMD,
-
-     // indicator ioctl's
-     IND_CMD_PULSE_TRAIN,                         // initiate a train of on/off pulses on LED and/or buzzer
-     IND_CMD_LED_SET,                             // set LED to a specific colour or turn it off
-     IND_CMD_BUZZER_SET,                          // set buzzer to a specific frequency or turn it off
-     IND_CMD_LED_GET,                             // request to provide the current state of the LED
-     IND_CMD_BUZZER_GET,                          // request to provide the current state of the buzzer
-     IND_CMD_PULSE_TRAIN_GET,                     // request to provide current state of pulse train
-
-     // system ioctl's
-     SYS_CMD_SOM_IS_UP,                           // message from SOM to MCU that is has started up
-     SYS_CMD_SHUTDOWN,                            // command from SOM to MCU to shutdown
-     SYS_CMD_GET_FW_VER,                          // command from SOM to MCU to get firmware version
-	SYS_CMD_GET_STATS1,                          // get page 1 of statistics
-	SYS_CMD_GET_STATS2,                          // get page 2 of statistics
-	SYS_CMD_GET_STATS3,                          // get page 3 of statistics
-	SYS_CMD_GET_STATS4,                          // get page 4 of statistics
-	SYS_CMD_ZAP_STATS,                           // clear all statistics counters
-
-     // motor ioctl's
-     MOTOR_CMD_ACCEPT_PROFILE,                    // accept current profile
-     MOTOR_CMD_ADC_OFFSET_GET,                    // request to provide ADC idle value
-     MOTOR_CMD_GOTO,                              // move to home/to snap/up/down
-     MOTOR_CMD_SOM_CONTROL_BRAKE,                 // direct SOM control motor brake
-     MOTOR_CMD_SOM_CONTROL_POWEROFF,              // direct SOM control motor power off
-     MOTOR_CMD_SOM_CONTROL_CCW,                   // direct SOM control motor counter-clockwise
-     MOTOR_CMD_SOM_CONTROL_CW,                    // direct SOM control motor clockwise
-     MOTOR_CMD_SOM_CONTROL_PWM,                   // direct SOM control set PWM duty cycle and frequency
-     MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,         // direct SOM control disable motor
-     MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,          // direct SOM control enable motor
-     MOTOR_CMD_SOM_CONTROL_PROFILE_OFF,           // direct SOM control disable current profile transmission
-     MOTOR_CMD_SOM_CONTROL_PROFILE_ON,            // direct SOM control enable current profile transmission
-
-     // protocol ioctl's, do not require communication with MCU; must be last in this enum
-     PROT_CMD_GET_STATISTICS1,                    // get the 1st page of error statistics from the driver
-#define FIRST_PROTOCOL_IOCTL PROT_CMD_GET_STATISTICS1
-     PROT_CMD_GET_STATISTICS2,                    // get the 2nd page of error statistics from the driver
-     PROT_CMD_GET_STATISTICS3,                    // get the 3rd page of error statistics from the driver
-     PROT_CMD_ZAP_STATISTICS,                     // set all the statistics counters to 0
-
-     NUMBER_OF_SOM_IOCTLS
-
-} SOM_ioctl_cmd;
-
-typedef enum
-{
-     // unknown notification
-     NOTIFY_UNKNOWN,
-
-     // indicator notifications
-     IND_NOTIFY_INVALID_COMMAND,                  // MCU received an indicator command it does not understand
-
-     // system notifications
-     SYS_NOTIFY_BUTTON_UP,                        // power button was pressed to wake up
-     SYS_NOTIFY_CORRUPTION,                       // corruption of RAM or code bug detected
-     SYS_NOTIFY_POWER_UP,                         // MCU is cold-starting
-     SYS_NOTIFY_POWER_FAIL,                       // battery power is failing
-     SYS_NOTIFY_SHUTDOWN,                         // power button was pressed to shut down
-	SYS_NOTIFY_WATCHDOG_RESET,                   // watchdog reset occurred
-     SYS_NOTIFY_INVALID_COMMAND,                  // MCU received a system command it does not understand
-
-     // motor notifications
-     MOTOR_NOTIFY_GOTO_COMPLETE,                  // move to home/to snap/up/down is complete
-     MOTOR_NOTIFY_SNAP_INSERTED,                  // cartridge has been inserted
-     MOTOR_NOTIFY_SNAP_EJECTED,                   // cartridge has been ejected
-     MOTOR_NOTIFY_HOME_POSITION_REACHED,          // home position hall effect sensor reached
-     MOTOR_NOTIFY_HOME_POSITION_LEFT,             // home position hall effect sensor left
-     MOTOR_NOTIFY_SNAP_POSITION_REACHED,          // snap position hall effect sensor reached
-     MOTOR_NOTIFY_SNAP_POSITION_LEFT,             // snap position hall effect sensor left
-     MOTOR_NOTIFY_SNAP_DOOR_UP,                   // the snap door is up
-     MOTOR_NOTIFY_SNAP_DOOR_DOWN,                 // the snap door is down
-     MOTOR_NOTIFY_MOTOR_STALL_DETECTED,           // stall current detected
-     MOTOR_NOTIFY_INVALID_COMMAND,                // MCU received a motor command it does not understand
-
-     // battery notifications
-     BATT_NOTIFY_CHARGER_IN,                      // charger plugged in
-     BATT_NOTIFY_CHARGER_OUT,                     // charger unplugged
-     BATT_NOTIFY_100mA,                           // charging at 100 mA
-     BATT_NOTIFY_500mA,                           // charging at 500 mA
-     BATT_NOTIFY_1A,                              // charging at 1 A
-     BATT_NOTIFY_INVALID_COMMAND,                 // MCU received a battery command it does not understand
-
-     // protocol notifications
-     PROTOCOL_NOTIFY_RESET_RECEIVED,              // link reset command has been received from MCU
-     PROTOCOL_NOTIFY_RESET_RECEIVED_COMPLETE,     // we have acked a received link reset command
-     PROTOCOL_NOTIFY_RESET_RECEIVED_FAILED,       // processing of a received link reset command has failed
-     PROTOCOL_NOTIFY_RESET_INITIATED,             // link reset has been initiated by the driver because it detected a hard link failure condition
-     PROTOCOL_NOTIFY_RESET_INITIATED_COMPLETE,    // link reset initiated by the driver has been acked
-     PROTOCOL_NOTIFY_RESET_INITIATED_FAILED,      // processing of a link reset initiated by the driver failed
-     PROTOCOL_NOTIFY_TOO_LONG,                    // there was a notification with data size larger than the allowed maximum
-     PROTOCOL_NOTIFY_LOST_PACKET,                 // received a packet (not current profile) with no ioctl waiting for it
-     PROTOCOL_NOTIFY_LOST_PROFILE,                // received a current profile packet with no ioctl waiting for it or ready to consume it
-     PROTOCOL_NOTIFY_LOST_NOTIFICATIONS,          // some notifications from MCU were lost due to notification FIFO overflow
-     PROTOCOL_NOTIFY_LOST_ACKS,                   // some ACK's to the MCU were lost due to ACK FIFO overflow
-
-     NUMBER_OF_NOTIFICATIONS
-
-} MCU_Notification;
-
-typedef enum
-{
-     MOTOR_LOCATION_UNKNOWN = 0,          // 0 used in reporting current location
-     MOTOR_LOCATION_HOME,                 // 1 at home position
-     MOTOR_LOCATION_SNAP,                 // 2 at snap position
-     MOTOR_LOCATION_UP,                   // 3 at the upper physical stop (a little past home position)
-     MOTOR_LOCATION_UP_IGNORE_STALL,      // 4 keep motor moving up no matter what
-     MOTOR_LOCATION_DOWN,                 // 5 at the lower physical stop (a little past snap position)
-     MOTOR_LOCATION_DOWN_IGNORE_STALL,    // 6 keep motor moving down no matter what
-
-} MotorLocation;
-
-typedef enum
-{
-     MOTOR_COND_PRESENT = 1,            // 1 condition must be present
-     MOTOR_COND_ABSENT,                 // 2 condition must be absent
-     MOTOR_COND_IGNORE,                 // 3 ignore condition
-
-} MotorCondCheck;
-
-typedef enum
-{
-     MOTOR_STATUS_SUCCESS = 1,          // 1 all good
-     MOTOR_STATUS_CARTRIDGE_FAIL,       // 2 state of cartridge presence was not as requested
-     MOTOR_STATUS_CARTRIDGE_CHANGE,     // 3 state of cartridge presence was as requested originally, but changed during move
-     MOTOR_STATUS_DOOR_FAIL,            // 4 state of the door was not as requested
-     MOTOR_STATUS_DOOR_CHANGE,          // 5 state of the door was as requested originally, but changed during move
-     MOTOR_STATUS_TIMEOUT,              // 6 timed out while trying to reach the target location
-     MOTOR_STATUS_ABORT,                // 7 aborted on request from SOM
-
-} MotorMoveStatus;
-
-typedef enum
-{
-     MOTOR_FREQ_15000 = 1,
-     MOTOR_FREQ_20000,
-     MOTOR_FREQ_24000,
-
-} MotorPWMFrequency;
-
-// input/output data structures for ioctl's
-
-#pragma pack(push, 1)
-
-// notifications require a 4-byte output buffer, it will be filled as follows. data field of the structure is used only by MOTOR_NOTIFY_GOTO_COMPLETE
-// and all ...NOTIFY_INVALID_COMMAND notifications.
-typedef struct
-{
-     u8   type;
-     u8   data[3];
-} MCU_NotificationInfo;
-
-typedef struct      // IND_CMD_PULSE_TRAIN input and IND_CMD_PULSE_TRAIN_GET output format
-{
-     u16  pulsePeriod;        // time period in ms to for the full on/off pulse, 0 if pulse train is not active
-     u16  onTimeLed;          // time period in ms to keep LED on (must be <= than pulsePediod)
-     u16  onTimeBuzzer;       // time period in ms to keep buzzer on (must be <= than pulsePediod)
-     u8   numPulsesLed;       // number of the (remaining) LED pulses in this pulse train, 0xFF = forever
-     u8   numPulsesBuzzer;    // number of the (remaining) buzzer pulses in this pulse train, 0xFF = forever
-     u8   buzzerFreq;         // number of a predefined buzzer frequency (1-25) during onTime, 0 or a number > 25 turns it off
-     u8   ledRedValue;        // red colour intensity (1-255) during onTime, 0 to turn it off
-     u8   ledGreenValue;      // green colour intensity (1-255) during onTime, 0 to turn it off
-     u8   ledBlueValue;       // blue colour intensity (1-255) during onTime, 0 to turn it off
-
-} IndPulseTrainCmd;
-
-typedef struct      // IND_CMD_LED_SET input and IND_CMD_LED_GET output format
-{
-     u8   ledRedValue;        // red colour intensity (1-255), 0 to turn it off
-     u8   ledGreenValue;      // green colour intensity (1-255), 0 to turn it off
-     u8   ledBlueValue;       // blue colour intensity (1-255), 0 to turn it off
-
-} IndLEDCmd;
-
-typedef struct      // IND_CMD_BUZZER_SET input and IND_CMD_BUZZER_GET output format
-{
-     u8   buzzerFreq;    // number of a predefined buzzer frequency (1-25), 0 or a number > 25 turns it off
-
-} IndBuzzerCmd;
-
-typedef struct      // MOTOR_CMD_ACCEPT_PROFILE output format
-{
-     u32  bufSize;            // size of the buffer starting with this structure
-     u32  numSamples;         // number of samples in the buffer
-     u32  numMissedSamples;   // number of samples we missed (due to bandwidth problems)
-     u16  samples[1];         // the dimension of the array is variable
-
-} MotorCurProfile;
-
-typedef struct      // MOTOR_CMD_GOTO input format
-{
-     u8   id;                 // distinguishing ID of this command
-     u8   target;             // where to move, MotorLocation range and semantics of values
-     u8   cartridgePresent;   // whether to check for cartridge presence, MotorCondCheck range and semantics of values
-     u8   doorClosed;         // whether to check the door state, MotorCondCheck range and semantics of values
-     u8   xmitProfile;        // 0 = do not transmit current profile, 1 = transmit current profile
-
-} MotorGotoCmd;
-
-typedef struct      // MOTOR_NOTIFY_GOTO_COMPLETE output format
-{
-     u8   id;                 // distinguishing ID of this command
-     u8   currentLocation;    // where the motor is now, MotorLocation range and semantics of values
-     u8   status;             // MotorMoveStatus range and semantics of values
-
-} MotorGotoCompleteCmd;
-
-typedef struct      // MOTOR_CMD_SOM_CONTROL_PWM format
-{
-     u8   freq;               // PWM frequency, MotorPWMFrequency range and semantics of values
-     u16  dutyCycle;          // 0 - 1023
-
-} MotorPWMCmd;
-
-typedef struct      // SYS_CMD_GET_FW_VER format
-{
-     u8             majorVersion;
-     u8             minorVersion;
-
-} SysFirmVerCmd;
-
-typedef struct      // PROT_CMD_GET_STATISTICS1 format
-{
-     u32 rx_timeoutCnt;                      // number of timeouts on reception that have occurred
-     u32 rx_brokenCnt;                       // number of broken messages that have been received
-     u32 rx_successCnt;                      // number of successfully received messages
-     u32 rx_wrongSTXCnt;                     // number of unexpected STX in packets
-     u32 rx_orphanedCnt;                     // number of received bytes not belonging to a packet
-     u32 rx_bugCnt;                          // number of occurrences in the parser that could not have happened
-     u32 rx_resetCnt;                        // number of received reset commands
-     u32 rx_resetFailedCnt;                  // number of failed received reset commands
-     u32 rx_overflowCnt;                     // number of UART overflow errors
-     u32 rx_framingCnt;                      // number of UART framing errors
-     u32 rx_parityCnt;                       // number of UART parity errors
-     u32 rx_wrongSeqCnt;                     // number of wrong sequence numbers in received packets
-
-} ProtStat1Cmd;
-
-typedef struct      // PROT_CMD_GET_STATISTICS2 format
-{
-     u32 rx_longNotCnt;                      // number of notifications too long to be accepted
-     u32 rx_repeatCnt;                       // number of repeated received packets
-     u32 rx_ackCnt;                          // number of received ACK's
-     u32 rx_lostProfileCnt;                  // number of unconsumed current profile packets
-     u32 rx_lostPacketCnt;                   // number of unconsumed non-current profile packets
-     u32 tx_noackCnt;                        // the number of non-acknowledged transmitted packets
-     u32 tx_reXmitCnt;                       // the number of packet re-transmissions
-     u32 tx_resetCnt;                        // number of initiated reset commands
-     u32 tx_resetFailedCnt;                  // number of failed initiated reset commands
-     u32 tx_packetsCnt;                      // number of transmitted packets
-     u32 tx_acksCnt;                         // number of transmitted acks
-     u32 RxTxHardCnt;                        // number of protocol hard errors.
-
-} ProtStat2Cmd;
-
-typedef struct      // PROT_CMD_GET_STATISTICS3 format
-{
-     u32 rx_fifoOverrunCnt;                  // number of ACK FIFO overruns
-     u32 notFifoOverrunCnt;                  // number of notification FIFO overruns
-     u32 tx_timeoutCnt;                      // the number of ioctl timeouts
-     u32 rx_tempBufCnt;                      // number of times extra current profile buffer was used
-} ProtStat3Cmd;
-
-typedef struct      // SYS_CMD_GET_STATS1 format
-{
-     u32 rx_timeoutCnt;            // RX packet timeouts
-     u32 rx_brokenCnt;             // RX broken messages
-     u32 rx_successCnt;            // RX successful packets
-     u32 rx_wrongSTXCnt;           // RX unexpected STX in packets
-     u32 rx_orphanedCnt;           // RX bytes not belonging to a packet
-     u32 rx_bugCnt;                // RX occurrences that could not have happened (bug)
-     u32 rx_resetCnt;              // received reset commands
-     u32 rx_resetFailedCnt;        // failed received reset commands
-     u32 rx_overflowCnt;           // UART overflow errors
-     u32 rx_framingCnt;            // UART framing errors
-     u32 rx_parityCnt;             // UART parity errors
-     u32 rx_wrongSeqCnt;           // RX wrong sequence numbers
-
-} SysStats1Cmd;
-
-typedef struct      // SYS_CMD_GET_STATS2 format
-{
-     u32 rx_overrunCnt;            // RX packet buffer overruns
-     u32 rx_repeatCnt;             // RX repeated packets
-     u32 rx_ackCnt;                // RX ACK's
-     u8  rx_freeBuffers;           // free RX buffers
-     u8  tx_freeBuffers;           // free TX buffers
-     u32 tx_noackCnt;              // non-acknowledged TX packets
-     u32 tx_reXmitCnt;             // packet re-transmissions
-     u32 tx_resetCnt;              // initiated reset commands
-     u32 tx_resetFailedCnt;        // failed initiated reset commands
-     u32 tx_packetsCnt;            // TX packets
-     u32 tx_acksCnt;               // TX ACK's
-     u32 RxTxHardCnt;              // hard errors
-
-} SysStats2Cmd;
-
-typedef struct      // SYS_CMD_GET_STATS3 format
-{
-     u32 rx_fifoOverrunCnt;        // ACK FIFO overruns
-     u32 notifyFifoOverruns;       // notifications FIFO overruns
-     u32 rx_buf0usage;             // RX buffer 0 usage count
-     u32 rx_buf1usage;             // RX buffer 1 usage count
-     u32 rx_buf2usage;             // RX buffer 2 usage count
-     u32 rx_buf3usage;             // RX buffer 3 usage count
-     u32 tx_buf0usage;             // TX buffer 0 usage count
-     u32 tx_buf1usage;             // TX buffer 1 usage count
-     u32 tx_buf2usage;             // TX buffer 2 usage count
-     u32 tx_buf3usage;             // TX buffer 3 usage count
-     u32 profNoBuffers;            // occurrences when a TX buffer was not available for current profile
-     u32 wdResetCnt;               // watchdog resets
-
-} SysStats3Cmd;
-
-typedef struct      // SYS_CMD_GET_STATS4 format
-{
-     u32 powerUpCnt;               // power-ups
-     u32 powerDownCnt;             // power-downs
-     u32 snapCnt;                  // snap motor movements
-     u32 homeCnt;                  // home motor movements
-     u32 eventFifoOverruns;        // event FIFO overruns
-
-} SysStats4Cmd;
-
-typedef struct
-{
-     union
-     {
-          IndPulseTrainCmd         pulseTrain;
-          IndLEDCmd                rgbLed;
-          IndBuzzerCmd             buzzerFreq;
-          MotorCurProfile          currentProfile;
-          MotorGotoCmd             motorMove;
-          MotorGotoCompleteCmd     motorMoveResult;
-          MotorPWMCmd              motorPower;
-          SysFirmVerCmd            firmwareVersion;
-          MCU_NotificationInfo     notification;
-          ProtStat1Cmd             localStats1;
-          ProtStat2Cmd             localStats2;
-          ProtStat3Cmd             localStats3;
-          SysStats1Cmd             mcuStats1;
-          SysStats2Cmd             mcuStats2;
-          SysStats3Cmd             mcuStats3;
-          SysStats4Cmd             mcuStats4;
-
-     } data;    // either input or output
-
-} idexxmcu_message_t;
-#pragma pack(pop)
-
-// Ioctl 
-// This ioctl will receive all notifications from the MCU.  This will typically be called in a separate thread.
-// This function will block until it is woken up by the kernel v with a message dispatched from the MCU
-#define IDEXX_MCU_NOTIFICATION_CMD _IOR(IDEXXMCU_PROTO_MAGIC, NOTIFICATION_CMD, idexxmcu_message_t)
-
-// indicator ioctl's
-#define IDEXX_MCU_IND_CMD_PULSE_TRAIN _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN, idexxmcu_message_t)
-#define IDEXX_MCU_IND_CMD_LED_SET _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_LED_SET, idexxmcu_message_t)
-#define IDEXX_MCU_IND_CMD_BUZZER_SET _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_BUZZER_SET, idexxmcu_message_t)
-#define IDEXX_MCU_IND_CMD_LED_GET _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_LED_GET, idexxmcu_message_t)
-#define IDEXX_MCU_IND_CMD_BUZZER_GET _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_BUZZER_GET, idexxmcu_message_t)
-#define IDEXX_MCU_IND_CMD_PULSE_TRAIN_GET _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN_GET, idexxmcu_message_t)
-
-// system ioctl's
-#define IDEXX_MCU_SYS_CMD_SOM_IS_UP _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_SOM_IS_UP)
-#define IDEXX_MCU_SYS_CMD_SHUTDOWN _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_SHUTDOWN)
-#define IDEXX_MCU_SYS_CMD_GET_FW_VER _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_FW_VER, idexxmcu_message_t)
-#define IDEXX_MCU_SYS_CMD_GET_STATS1 _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS1, idexxmcu_message_t)
-#define IDEXX_MCU_SYS_CMD_GET_STATS2 _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS2, idexxmcu_message_t)
-#define IDEXX_MCU_SYS_CMD_GET_STATS3 _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS3, idexxmcu_message_t)
-#define IDEXX_MCU_SYS_CMD_GET_STATS4 _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS4, idexxmcu_message_t)
-#define IDEXX_MCU_SYS_CMD_ZAP_STATS _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_ZAP_STATS)
-
-// motor ioctl's
-// This ioctl is a special case and requires a pointer to a large user space buffer
-// and it will also block until the entire profile is received.  The allocated
-// buffer should be protected from access in the user space.
-#define IDEXX_MCU_MOTOR_CMD_ACCEPT_PROFILE _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACCEPT_PROFILE, idexxmcu_message_t)
-
-#define IDEXX_MCU_MOTOR_CMD_ADC_OFFSET_GET _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ADC_OFFSET_GET, idexxmcu_message_t)
-#define IDEXX_MCU_MOTOR_CMD_GOTO _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_GOTO)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_BRAKE _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_BRAKE)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_POWEROFF _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_POWEROFF)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_CCW _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_CCW)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_CW _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_CW)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PWM _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PWM, idexxmcu_message_t)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PROFILE_OFF _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PROFILE_OFF)
-#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PROFILE_ON _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PROFILE_ON)
-
-// protocol ioctl's
-#define IDEXX_MCU_PROT_CMD_GET_STATISTICS1 _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS1, idexxmcu_message_t)
-#define IDEXX_MCU_PROT_CMD_GET_STATISTICS2 _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS2, idexxmcu_message_t)
-#define IDEXX_MCU_PROT_CMD_GET_STATISTICS3 _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS3, idexxmcu_message_t)
-#define IDEXX_MCU_PROT_CMD_ZAP_STATISTICS  _IO(IDEXXMCU_PROTO_MAGIC, PROT_CMD_ZAP_STATISTICS)
-
-#endif    // SOM_MCU_IOCTL_DESC_H
+#ifndef SOM_MCU_IOCTL_DESC_H
+#define SOM_MCU_IOCTL_DESC_H
+
+static const char idexxmcu_ioctl_h_version[] = "0.2.1-m";
+
+#ifndef __KERNEL__
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef unsigned long u64;
+#endif
+
+#define  IDEXXMCU_PROTO_MAGIC  0x83
+
+#define   EPROM_DATA_PAGE_SIZE 30
+#define   DRIVER_VERSION_SIZE  20
+#define   MAX_DATA_LENGTH      49       // maximum allowed number of data characters in a packet
+#define   MCU_NUMBER_OF_TASKS  5        // number of tasks in the MCU
+
+
+typedef enum
+{
+    // the special ioctl to for all notifications, must be the first in this enum
+    NOTIFICATION_CMD,
+
+    // indicator ioctl's
+    IND_CMD_PULSE_TRAIN,                         // initiate a train of on/off pulses on LED and/or buzzer
+    IND_CMD_LED_SET,                             // set LED to a specific colour or turn it off
+    IND_CMD_BUZZER_SET,                          // set buzzer to a specific frequency or turn it off
+    IND_CMD_LED_GET,                             // request to provide the current state of the LED
+    IND_CMD_BUZZER_GET,                          // request to provide the current state of the buzzer
+    IND_CMD_PULSE_TRAIN_GET,                     // request to provide current state of pulse train
+    IND_CMD_PULSE_TRAIN_DEF_GET,                 // request to provide current definition of a pulse train
+    IND_CMD_PULSE_TRAIN_DEF_SET,                 // command to change definition of a pulse train
+    IND_CMD_PLACEHOLDER3,
+    IND_CMD_PLACEHOLDER4,
+    IND_CMD_PLACEHOLDER5,
+    IND_CMD_PLACEHOLDER6,
+    IND_CMD_PLACEHOLDER7,
+    IND_CMD_PLACEHOLDER8,
+    IND_CMD_PLACEHOLDER9,
+    IND_CMD_PLACEHOLDER10,
+
+    // system ioctl's
+    SYS_CMD_SOM_IS_UP,                           // message from SOM to MCU that is has started up
+    SYS_CMD_SHUTDOWN,                            // command from SOM to MCU to shutdown
+    SYS_CMD_GET_FW_VER,                          // command from SOM to MCU to get firmware version
+    SYS_CMD_GET_STATS1,                          // get page 1 of statistics
+    SYS_CMD_GET_STATS2,                          // get page 2 of statistics
+    SYS_CMD_GET_STATS3,                          // get page 3 of statistics
+    SYS_CMD_GET_STATS4,                          // get page 4 of statistics
+    SYS_CMD_ZAP_STATS,                           // clear all statistics counters
+    SYS_CMD_EPROM_PAGE_GET,                      // request to get EEPROM page contents
+    SYS_CMD_EPROM_PAGE_SET,                      // request to set EEPROM page contents
+    SYS_CMD_EPROM_PAGE_ERASE,                    // request to erase EEPROM page contents
+    SYS_CMD_STACK_SIZES_GET,                     // request to provide tasks' used stack sizes
+    SYS_CMD_PLACEHOLDER2,
+    SYS_CMD_PLACEHOLDER3,
+    SYS_CMD_PLACEHOLDER4,
+    SYS_CMD_PLACEHOLDER5,
+    SYS_CMD_PLACEHOLDER6,
+    SYS_CMD_PLACEHOLDER7,
+    SYS_CMD_PLACEHOLDER8,
+    SYS_CMD_PLACEHOLDER9,
+    SYS_CMD_PLACEHOLDER10,
+
+    // motor ioctl's
+    MOTOR_CMD_ACCEPT_PROFILE,                    // accept current profile
+    MOTOR_CMD_ADC_OFFSET_GET,                    // request to provide ADC idle value
+    MOTOR_CMD_GOTO,                              // move to home/to snap/up/down
+    MOTOR_CMD_GOTO_WITH_PROFILE,                 // move to home/to snap/up/down only if a thread is waiting on current profile
+    MOTOR_CMD_SOM_CONTROL_BRAKE,                 // direct SOM control motor brake
+    MOTOR_CMD_SOM_CONTROL_POWEROFF,              // direct SOM control motor power off
+    MOTOR_CMD_SOM_CONTROL_CCW,                   // direct SOM control motor counter-clockwise
+    MOTOR_CMD_SOM_CONTROL_CW,                    // direct SOM control motor clockwise
+    MOTOR_CMD_SOM_CONTROL_PWM,                   // direct SOM control set PWM duty cycle and frequency
+    MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE,         // direct SOM control disable motor
+    MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE,          // direct SOM control enable motor
+    MOTOR_CMD_SOM_CONTROL_PROFILE_OFF,           // direct SOM control disable current profile transmission
+    MOTOR_CMD_SOM_CONTROL_PROFILE_ON,            // direct SOM control enable current profile transmission
+    MOTOR_CMD_STALL_CURRENT_GET,                 // request to provide stall current threshold value
+    MOTOR_CMD_STALL_CURRENT_SET,                 // command to set stall current threshold to a specific value
+    MOTOR_CMD_ALL_PARMS_GET,                     // request to provide of all motor parameters
+    MOTOR_CMD_ALL_PARMS_SET,                     // command to set all motor parameters to specific values
+    MOTOR_CMD_STALL_SAMPLES_GET,                 // request to provide stall current minimum samples value
+    MOTOR_CMD_STALL_SAMPLES_SET,                 // command to set stall current minimum samples to a specific value
+    MOTOR_CMD_NO_STALL_CURRENT_GET,              // request to provide no-stall current ADC threshold value
+    MOTOR_CMD_NO_STALL_CURRENT_SET,              // command to set no-stall current ADC threshold to a specific value
+    MOTOR_CMD_NO_STALL_SAMPLES_GET,              // request to provide no-stall current minimum samples value
+    MOTOR_CMD_NO_STALL_SAMPLES_SET,              // command to set no-stall current minimum samples to a specific value
+    MOTOR_CMD_TIMEOUT_SNAP_GET,                  // request to provide snap move timeout value (seconds)
+    MOTOR_CMD_TIMEOUT_SNAP_SET,                  // command to set snap move timeout to a specific value (seconds)
+    MOTOR_CMD_TIMEOUT_HOME_GET,                  // request to provide home move timeout value (seconds)
+    MOTOR_CMD_TIMEOUT_HOME_SET,                  // command to set home move timeout to a specific value (seconds)
+    MOTOR_CMD_TIMEOUT_UP_GET,                    // request to provide up move timeout value (seconds)
+    MOTOR_CMD_TIMEOUT_UP_SET,                    // command to set up move timeout to a specific value (seconds)
+    MOTOR_CMD_TIMEOUT_DOWN_GET,                  // request to provide down move timeout value (seconds)
+    MOTOR_CMD_TIMEOUT_DOWN_SET,                  // command to set down move timeout to a specific value (seconds)
+    MOTOR_CMD_MAX_PWM_GET,                       // request to provide full power PWM value (0-1023)
+    MOTOR_CMD_MAX_PWM_SET,                       // command to set full power PWM to a specific value (0-1023)
+    MOTOR_CMD_FREQ_GET,                          // request to provide PWM frequency value
+    MOTOR_CMD_FREQ_SET,                          // command to set PWM frequency to a specific value
+    MOTOR_CMD_ACC_PROF_GET,                      // request to provide acceleration profile number (0-5)
+    MOTOR_CMD_ACC_PROF_SET,                      // command to set acceleration profile to a specific number (0-5)
+    MOTOR_CMD_ACC_STEP_GET,                      // request to provide acceleration profile step value (ms)
+    MOTOR_CMD_ACC_STEP_SET,                      // command to set acceleration profile step to a specific value (ms)
+    MOTOR_CMD_DEC_PROF_GET,                      // request to provide deceleration profile number (0-5)
+    MOTOR_CMD_DEC_PROF_SET,                      // command to set deceleration profile to a specific number (0-5)
+    MOTOR_CMD_DEC_STEP_GET,                      // request to provide deceleration profile step value (ms)
+    MOTOR_CMD_DEC_STEP_SET,                      // command to set deceleration profile step to a specific value (ms)
+    MOTOR_CMD_UP_DIR_GET,                        // request to provide motor control setting for moving up (MotorDiection enum)
+    MOTOR_CMD_UP_DIR_SET,                        // command to set motor control setting for moving up to a specific value (MotorDiection enum)
+    MOTOR_CMD_PROFILE_ARRAY_GET,                 // request to provide the 6-byte array of acceleration or deceleration profiles
+    MOTOR_CMD_PROFILE_ARRAY_SET,                 // command to set the 6-byte array of acceleration or deceleration profiles
+    MOTOR_CMD_ALL_SENSORS_GET,                   // request to provide state of all sensors
+    MOTOR_CMD_PLACEHOLDER4,
+    MOTOR_CMD_PLACEHOLDER5,
+    MOTOR_CMD_PLACEHOLDER6,
+    MOTOR_CMD_PLACEHOLDER7,
+    MOTOR_CMD_PLACEHOLDER8,
+    MOTOR_CMD_PLACEHOLDER9,
+    MOTOR_CMD_PLACEHOLDER10,
+
+    // battery ioctl's
+    BATT_CMD_GET_STATUS,                         // get status of the battery
+    BATT_CMD_GET_GG_VERSION,                     // get gas gauge IC type and firmware version
+    BATT_CMD_OBSOLETE1,                          // used to be BATT_CMD_GET_GG_DFI_CHECKSUM,                // get gas gauge data flash check sum
+    BATT_CMD_OBSOLETE2,                          // used to be BATT_CMD_GG_DFI_FLASH,                       // flash data flash "golden image" onto the gas gauge IC
+    BATT_CMD_FS_PKT,                             // request to process a flashstream packet
+    BATT_CMD_OVERRIDE_CHARGE_RATE,               // request to override battery charger rate
+    BATT_CMD_PLACEHOLDER3,
+    BATT_CMD_PLACEHOLDER4,
+    BATT_CMD_PLACEHOLDER5,
+    BATT_CMD_PLACEHOLDER6,
+    BATT_CMD_PLACEHOLDER7,
+    BATT_CMD_PLACEHOLDER8,
+    BATT_CMD_PLACEHOLDER9,
+    BATT_CMD_PLACEHOLDER10,
+
+    // protocol ioctl's, do not require communication with MCU; must be last in this enum
+    PROT_CMD_GET_STATISTICS1,                    // get the 1st page of error statistics from the driver
+#define FIRST_PROTOCOL_IOCTL PROT_CMD_GET_STATISTICS1
+    PROT_CMD_GET_STATISTICS2,                    // get the 2nd page of error statistics from the driver
+    PROT_CMD_GET_STATISTICS3,                    // get the 3rd page of error statistics from the driver
+    PROT_CMD_ZAP_STATISTICS,                     // set all the statistics counters to 0
+    PROT_CMD_GET_DRIVER_VERSION,                 // get the driver version
+    PROT_CMD_PLACEHOLDER1,
+    PROT_CMD_PLACEHOLDER2,
+    PROT_CMD_PLACEHOLDER3,
+    PROT_CMD_PLACEHOLDER4,
+    PROT_CMD_PLACEHOLDER5,
+    PROT_CMD_PLACEHOLDER6,
+    PROT_CMD_PLACEHOLDER7,
+    PROT_CMD_PLACEHOLDER8,
+    PROT_CMD_PLACEHOLDER9,
+    PROT_CMD_PLACEHOLDER10,
+
+    NUMBER_OF_SOM_IOCTLS
+
+} SOM_ioctl_cmd;
+
+typedef enum
+{
+    // unknown notification
+    NOTIFY_UNKNOWN,
+
+    // indicator notifications
+    IND_NOTIFY_PLACEHOLDER1,
+    IND_NOTIFY_PLACEHOLDER2,
+    IND_NOTIFY_PLACEHOLDER3,
+    IND_NOTIFY_PLACEHOLDER4,
+    IND_NOTIFY_PLACEHOLDER5,
+    IND_NOTIFY_PLACEHOLDER6,
+    IND_NOTIFY_PLACEHOLDER7,
+    IND_NOTIFY_PLACEHOLDER8,
+    IND_NOTIFY_PLACEHOLDER9,
+    IND_NOTIFY_PLACEHOLDER10,
+    IND_NOTIFY_INVALID_COMMAND,                  // MCU received an indicator command it does not understand
+
+    // system notifications
+    SYS_NOTIFY_BUTTON_UP,                        // power button was pressed to wake up
+    SYS_NOTIFY_CORRUPTION,                       // corruption of RAM or code bug detected
+    SYS_NOTIFY_POWER_UP,                         // MCU is cold-starting
+    SYS_NOTIFY_POWER_FAIL,                       // battery power is failing
+    SYS_NOTIFY_SHUTDOWN,                         // power button was pressed to shut down
+    SYS_NOTIFY_WATCHDOG_RESET,                   // watchdog reset occurred
+    SYS_NOTIFY_INVALID_EPROM_PAGE,               // invalid EEPROM page number specified in SYS_CMD_EPROM_PAGE_SET command
+    SYS_NOTIFY_PLACEHOLDER1,
+    SYS_NOTIFY_PLACEHOLDER2,
+    SYS_NOTIFY_PLACEHOLDER3,
+    SYS_NOTIFY_PLACEHOLDER4,
+    SYS_NOTIFY_PLACEHOLDER5,
+    SYS_NOTIFY_PLACEHOLDER6,
+    SYS_NOTIFY_PLACEHOLDER7,
+    SYS_NOTIFY_PLACEHOLDER8,
+    SYS_NOTIFY_PLACEHOLDER9,
+    SYS_NOTIFY_PLACEHOLDER10,
+    SYS_NOTIFY_INVALID_COMMAND,                  // MCU received a system command it does not understand
+
+    // motor notifications
+    MOTOR_NOTIFY_GOTO_COMPLETE,                  // move to home/to snap/up/down is complete
+    MOTOR_NOTIFY_SNAP_INSERTED,                  // cartridge has been inserted
+    MOTOR_NOTIFY_SNAP_EJECTED,                   // cartridge has been ejected
+    MOTOR_NOTIFY_HOME_POSITION_REACHED,          // home position hall effect sensor reached
+    MOTOR_NOTIFY_HOME_POSITION_LEFT,             // home position hall effect sensor left
+    MOTOR_NOTIFY_SNAP_POSITION_REACHED,          // snap position hall effect sensor reached
+    MOTOR_NOTIFY_SNAP_POSITION_LEFT,             // snap position hall effect sensor left
+    MOTOR_NOTIFY_SNAP_DOOR_UP,                   // the snap door is up
+    MOTOR_NOTIFY_SNAP_DOOR_DOWN,                 // the snap door is down
+    MOTOR_NOTIFY_MOTOR_STALL_DETECTED,           // stall current detected
+    MOTOR_NOTIFY_PLACEHOLDER1,
+    MOTOR_NOTIFY_PLACEHOLDER2,
+    MOTOR_NOTIFY_PLACEHOLDER3,
+    MOTOR_NOTIFY_PLACEHOLDER4,
+    MOTOR_NOTIFY_PLACEHOLDER5,
+    MOTOR_NOTIFY_PLACEHOLDER6,
+    MOTOR_NOTIFY_PLACEHOLDER7,
+    MOTOR_NOTIFY_PLACEHOLDER8,
+    MOTOR_NOTIFY_PLACEHOLDER9,
+    MOTOR_NOTIFY_PLACEHOLDER10,
+    MOTOR_NOTIFY_INVALID_COMMAND,                // MCU received a motor command it does not understand
+
+    // battery notifications
+    BATT_NOTIFY_CHARGER_IN,                      // charger plugged in
+    BATT_NOTIFY_CHARGER_OUT,                     // charger unplugged
+    BATT_NOTIFY_100mA,                           // charging at 100 mA
+    BATT_NOTIFY_500mA,                           // charging at 500 mA
+    BATT_NOTIFY_1A,                              // charging at 1 A
+    BATT_NOTIFY_GG_ERROR,                        // gas gauge transaction resulted in error
+    BATT_NOTIFY_OBSOLETE1,                       // used to be BATT_NOTIFY_GG_DFI_FLASH_DONE,               // data flash "golden image" has been flashed onto the gas gauge IC
+    BATT_NOTIFY_OBSOLETE2,                       // used to be BATT_NOTIFY_GG_DFI_FLASH_ERROR,              // error flashing data flash "golden image" onto the gas gauge IC
+    BATT_NOTIFY_FS_PKT_STATUS,                   // notification of success/failure in processing the last flashstream packet, also signals readiness for the next one
+    BATT_NOTIFY_CHARGE_OFF,                      // not charging even though charger is plugged in (forced by BATT_CMD_OVERRIDE_CHARGE_RATE)
+    BATT_NOTIFY_PLACEHOLDER3,
+    BATT_NOTIFY_PLACEHOLDER4,
+    BATT_NOTIFY_PLACEHOLDER5,
+    BATT_NOTIFY_PLACEHOLDER6,
+    BATT_NOTIFY_PLACEHOLDER7,
+    BATT_NOTIFY_PLACEHOLDER8,
+    BATT_NOTIFY_PLACEHOLDER9,
+    BATT_NOTIFY_PLACEHOLDER10,
+    BATT_NOTIFY_INVALID_COMMAND,                 // MCU received a battery command it does not understand
+
+    // protocol notifications
+    PROTOCOL_NOTIFY_RESET_RECEIVED,              // link reset command has been received from MCU
+    PROTOCOL_NOTIFY_RESET_RECEIVED_COMPLETE,     // we have acked a received link reset command
+    PROTOCOL_NOTIFY_RESET_RECEIVED_FAILED,       // processing of a received link reset command has failed
+    PROTOCOL_NOTIFY_RESET_INITIATED,             // link reset has been initiated by the driver because it detected a hard link failure condition
+    PROTOCOL_NOTIFY_RESET_INITIATED_COMPLETE,    // link reset initiated by the driver has been acked
+    PROTOCOL_NOTIFY_RESET_INITIATED_FAILED,      // processing of a link reset initiated by the driver failed
+    PROTOCOL_NOTIFY_TOO_LONG,                    // there was a notification with data size larger than the allowed maximum
+    PROTOCOL_NOTIFY_LOST_PACKET,                 // received a packet (not current profile) with no ioctl waiting for it
+    PROTOCOL_NOTIFY_LOST_PROFILE,                // received a current profile packet with no ioctl waiting for it or ready to consume it
+    PROTOCOL_NOTIFY_LOST_NOTIFICATIONS,          // some notifications from MCU were lost due to notification FIFO overflow
+    PROTOCOL_NOTIFY_LOST_ACKS,                   // some ACK's to the MCU were lost due to ACK FIFO overflow
+    PROTOCOL_NOTIFY_PLACEHOLDER1,
+    PROTOCOL_NOTIFY_PLACEHOLDER2,
+    PROTOCOL_NOTIFY_PLACEHOLDER3,
+    PROTOCOL_NOTIFY_PLACEHOLDER4,
+    PROTOCOL_NOTIFY_PLACEHOLDER5,
+    PROTOCOL_NOTIFY_PLACEHOLDER6,
+    PROTOCOL_NOTIFY_PLACEHOLDER7,
+    PROTOCOL_NOTIFY_PLACEHOLDER8,
+    PROTOCOL_NOTIFY_PLACEHOLDER9,
+    PROTOCOL_NOTIFY_PLACEHOLDER10,
+
+    NUMBER_OF_NOTIFICATIONS
+
+} MCU_Notification;
+
+// input/output data structures for ioctl's
+
+#pragma pack(push, 1)
+
+//============================================================================================
+// Definitions for MSG_TYPE_INDICATORS
+//============================================================================================
+typedef enum
+{
+    TYPE_POWERUP_INDICATOR = 1,
+    TYPE_WATCHDOG_RESET_INDICATOR,
+    TYPE_MALFUNCTION_INDICATOR,
+    TYPE_READY_INDICATOR,
+    TYPE_BUTTON_UP_INDICATOR,
+    TYPE_SHUTDOWN_INDICATOR,
+    TYPE_BATT_FULL_INDICATOR,
+    TYPE_BATT_CHARGING_INDICATOR,
+
+} IndicatorTypes;
+
+typedef struct      // IND_CMD_PULSE_TRAIN input and IND_CMD_PULSE_TRAIN_GET output format
+{
+    u16  pulsePeriod;        // time period in ms to for the full on/off pulse, 0 if pulse train is not active
+    u16  onTimeLed;          // time period in ms to keep LED on (must be <= than pulsePediod)
+    u16  onTimeBuzzer;       // time period in ms to keep buzzer on (must be <= than pulsePediod)
+    u8   numPulsesLed;       // number of the (remaining) LED pulses in this pulse train, 0xFF = forever
+    u8   numPulsesBuzzer;    // number of the (remaining) buzzer pulses in this pulse train, 0xFF = forever
+    u8   buzzerFreq;         // number of a predefined buzzer frequency (1-25) during onTime, 0 or a number > 25 turns it off
+    u8   ledRedValue;        // red colour intensity (1-255) during onTime, 0 to turn it off
+    u8   ledGreenValue;      // green colour intensity (1-255) during onTime, 0 to turn it off
+    u8   ledBlueValue;       // blue colour intensity (1-255) during onTime, 0 to turn it off
+
+} IndPulseTrainCmd;
+
+typedef struct      // IND_CMD_LED_SET input and IND_CMD_LED_GET output format
+{
+    u8   ledRedValue;        // red colour intensity (1-255), 0 to turn it off
+    u8   ledGreenValue;      // green colour intensity (1-255), 0 to turn it off
+    u8   ledBlueValue;       // blue colour intensity (1-255), 0 to turn it off
+
+} IndLEDCmd;
+
+typedef struct      // IND_CMD_BUZZER_SET input and IND_CMD_BUZZER_GET output format
+{
+    u8   buzzerFreq;    // number of a predefined buzzer frequency (1-25), 0 or a number > 25 turns it off
+
+} IndBuzzerCmd;
+
+typedef struct      // IND_CMD_PULSE_TRAIN_DEF_GET and IND_CMD_PULSE_TRAIN_DEF_SET format
+{
+    u8                  type;          // type of the indicator
+    IndPulseTrainCmd    definition;    // definition of the indicator
+
+} IndPulseTrainDefCmd;
+
+//============================================================================================
+// Definitions for MSG_TYPE_SYSTEM
+//============================================================================================
+typedef struct      // SYS_CMD_GET_FW_VER format
+{
+    u8             majorVersion;
+    u8             minorVersion;
+
+} SysFirmVerCmd;
+
+typedef struct      // SYS_CMD_GET_STATS1 format
+{
+    u32 rx_timeoutCnt;            // RX packet timeouts
+    u32 rx_brokenCnt;             // RX broken messages
+    u32 rx_successCnt;            // RX successful packets
+    u32 rx_wrongSTXCnt;           // RX unexpected STX in packets
+    u32 rx_orphanedCnt;           // RX bytes not belonging to a packet
+    u32 rx_bugCnt;                // RX occurrences that could not have happened (bug)
+    u32 rx_resetCnt;              // received reset commands
+    u32 rx_resetFailedCnt;        // failed received reset commands
+    u32 rx_overflowCnt;           // UART overflow errors
+    u32 rx_framingCnt;            // UART framing errors
+    u32 rx_parityCnt;             // UART parity errors
+    u32 rx_wrongSeqCnt;           // RX wrong sequence numbers
+
+} SysStats1Cmd;
+
+typedef struct      // SYS_CMD_GET_STATS2 format
+{
+    u32 rx_overrunCnt;            // RX packet buffer overruns
+    u32 rx_repeatCnt;             // RX repeated packets
+    u32 rx_ackCnt;                // RX ACK's
+    u8  rx_freeBuffers;           // free RX buffers
+    u8  tx_freeBuffers;           // free TX buffers
+    u32 tx_noackCnt;              // non-acknowledged TX packets
+    u32 tx_reXmitCnt;             // packet re-transmissions
+    u32 tx_resetCnt;              // initiated reset commands
+    u32 tx_resetFailedCnt;        // failed initiated reset commands
+    u32 tx_packetsCnt;            // TX packets
+    u32 tx_acksCnt;               // TX ACK's
+    u32 tx_flushedMsgCnt;         // TX flushed
+
+} SysStats2Cmd;
+
+typedef struct      // SYS_CMD_GET_STATS3 format
+{
+    u32 RxTxHardCnt;              // hard errors
+    u32 rx_fifoOverrunCnt;        // ACK FIFO overruns
+    u32 notifyFifoOverruns;       // notifications FIFO overruns
+    u32 rx_buf0usage;             // RX buffer 0 usage count
+    u32 rx_buf1usage;             // RX buffer 1 usage count
+    u32 rx_buf2usage;             // RX buffer 2 usage count
+    u32 rx_buf3usage;             // RX buffer 3 usage count
+    u32 tx_buf0usage;             // TX buffer 0 usage count
+    u32 tx_buf1usage;             // TX buffer 1 usage count
+    u32 tx_buf2usage;             // TX buffer 2 usage count
+    u32 tx_buf3usage;             // TX buffer 3 usage count
+    u32 tx_buf4usage;             // TX buffer 4 usage count
+
+} SysStats3Cmd;
+
+typedef struct      // SYS_CMD_GET_STATS4 format
+{
+    u32 profNoBuffers;            // occurrences when a TX buffer was not available for current profile
+    u32 wdResetCnt;               // watchdog resets
+    u32 powerUpCnt;               // power-ups
+    u32 powerDownCnt;             // power-downs
+    u32 snapCnt;                  // snap motor movements
+    u32 homeCnt;                  // home motor movements
+    u32 eventFifoOverruns;        // event FIFO overruns
+    u32 stallCnt;                 // stall current events
+    u32 badEpromCnt;              // CRC mismatches on EEPROM page read
+
+} SysStats4Cmd;
+
+typedef struct      // SYS_CMD_EPROM_PAGE and SYS_CMD_EPROM_PAGE_SET format
+{
+    u8 statusOrPageNum;                // for SYS_CMD_EPROM_PAGE 1 = success, 0 = CRC error; for SYS_CMD_EPROM_PAGE_SET page number
+    u8 data[EPROM_DATA_PAGE_SIZE];
+
+} SysEpromCmd;
+
+typedef u16 SysStacksCmd[MCU_NUMBER_OF_TASKS];    // SYS_CMD_STACK_SIZES_GET format
+
+//============================================================================================
+// Definitions for MSG_TYPE_MOTOR
+//============================================================================================
+typedef enum
+{
+    MOTOR_LOCATION_UNKNOWN = 0,          // 0 used in reporting current location
+    MOTOR_LOCATION_HOME,                 // 1 at home position
+    MOTOR_LOCATION_SNAP,                 // 2 at snap position
+    MOTOR_LOCATION_UP,                   // 3 at the upper physical stop (a little past home position)
+    MOTOR_LOCATION_UP_IGNORE_STALL,      // 4 keep motor moving up no matter what
+    MOTOR_LOCATION_DOWN,                 // 5 at the lower physical stop (a little past snap position)
+    MOTOR_LOCATION_DOWN_IGNORE_STALL,    // 6 keep motor moving down no matter what
+
+} MotorLocation;
+
+typedef enum
+{
+    MOTOR_COND_PRESENT = 1,            // 1 condition must be present
+    MOTOR_COND_ABSENT,                 // 2 condition must be absent
+    MOTOR_COND_IGNORE,                 // 3 ignore condition
+
+} MotorCondCheck;
+
+typedef enum
+{
+    MOTOR_STATUS_SUCCESS = 1,          // 1 all good
+    MOTOR_STATUS_CARTRIDGE_FAIL,       // 2 state of cartridge presence was not as requested
+    MOTOR_STATUS_CARTRIDGE_CHANGE,     // 3 state of cartridge presence was as requested originally, but changed during move
+    MOTOR_STATUS_DOOR_FAIL,            // 4 state of the door was not as requested
+    MOTOR_STATUS_DOOR_CHANGE,          // 5 state of the door was as requested originally, but changed during move
+    MOTOR_STATUS_TIMEOUT,              // 6 timed out while trying to reach the target location
+    MOTOR_STATUS_ABORT,                // 7 aborted on request from SOM
+    MOTOR_STATUS_DOWN_NO_CARTRIDGE,    // 8 direction of the move is down and cartridge is not present (hardware will not allow turning on the motor)
+
+} MotorMoveStatus;
+
+typedef enum
+{
+    MOTOR_FREQ_15000 = 1,
+    MOTOR_FREQ_20000,
+    MOTOR_FREQ_24000,
+
+} MotorPWMFrequency;
+
+typedef enum
+{
+    MOTOR_CW,           // clockwise
+    MOTOR_CCW,          // counter-clockwise
+    MOTOR_BRAKE,        // brake the motor
+    MOTOR_POWEROFF,     // no power applied to the motor
+
+} MotorDirection;
+
+typedef enum
+{
+    MOTOR_ACCEL_PROFILE_ARRAY = 1,
+    MOTOR_DECEL_PROFILE_ARRAY,
+
+} MotorProfileArrayType;
+
+typedef struct      // MOTOR_NOTIFY_GOTO_COMPLETE output format
+{
+    u8   id;                 // distinguishing ID of this command
+    u8   currentLocation;    // where the motor is now, MotorLocation range and semantics of values
+    u8   status;             // MotorMoveStatus range and semantics of values
+
+} MotorGotoCompleteCmd;
+
+typedef struct      // MOTOR_CMD_ACCEPT_PROFILE output format
+{
+    u32  bufSize;            // size of the buffer starting with this structure
+    u32  numSamples;         // number of samples in the buffer
+    u32  numMissedSamples;   // number of samples we missed (due to bandwidth problems)
+    u16  samples[1];         // the dimension of the array is variable
+
+} MotorCurProfile;
+
+typedef struct      // MOTOR_CMD_GOTO input format
+{
+    u8   id;                 // distinguishing ID of this command
+    u8   target;             // where to move, MotorLocation range and semantics of values
+    u8   cartridgePresent;   // whether to check for cartridge presence, MotorCondCheck range and semantics of values
+    u8   doorClosed;         // whether to check the door state, MotorCondCheck range and semantics of values
+    u8   xmitProfile;        // 0 = do not transmit current profile, 1 = transmit current profile
+
+} MotorGotoCmd;
+
+typedef struct      // MOTOR_CMD_SOM_CONTROL_PWM format
+{
+    u8   freq;               // PWM frequency, MotorPWMFrequency range and semantics of values
+    u16  dutyCycle;          // 0 - 1023
+
+} MotorPWMCmd;
+
+typedef struct      // MOTOR_CMD_ALL_PARMS_GET format
+{
+    u16  motorStallCurrent;       // current threshold at or above which motor is considered to be at stall
+    u16  motorStallSamples;       // number of consecutive ADC samples at or above the stall current threshold that constitute a stall current event
+    u16  motorNoStallCurrent;     // current threshold at or below which motor is considered not to be at stall
+    u16  motorNoStallSamples;     // number of consecutive ADC samples at or below the no-stall current threshold that constitute a no-stall current event
+    u8   motorTimeoutSnap;        // timeout for going to the snap position, in seconds
+    u8   motorTimeoutHome;        // timeout for going to the home position, in seconds
+    u8   motorTimeoutUp;          // timeout for going up, in seconds
+    u8   motorTimeoutDown;        // timeout for going down, in seconds
+    u16  reqMotorSpeed;           // PWM duty cycle for full motor power, 0-1023
+    u32  reqMotorFreq;            // frequency of the motor PWM control
+    u8   motorAccelProfile;       // acceleration profile number
+    u8   motorAccelStep;          // duration in ms of motor power increase steps
+    u8   motorDecelProfile;       // deceleration profile number
+    u8   motorDecelStep;          // duration in ms of motor power decrease steps
+    u8   motorUpDirection;        // setting to move motor up according to the MotorDirection enum
+
+} MotorAllParmsCmd;
+
+typedef struct      // MOTOR_CMD_PROFILE_ARRAY_GET and MOTOR_CMD_PROFILE_ARRAY_SET format
+{
+    u8   type;     // acceleration or deceleration
+    u8   array[6]; // the array
+
+} MotorProfileArrayCmd;
+
+typedef struct      // MOTOR_CMD_ALL_SENSORS_GET format
+{
+    u8   cartridgePresent : 1;    // 1 = cartridge present, 0 = not so
+    u8   atHome : 1;              // 1 = at home position, 0 = not so
+    u8   atSnap : 1;              // 1 = at snap position, 0 = not so
+    u8   door : 1;                // 1 = down, 0 = up
+
+} MotorAllSensorsCmd;
+
+//============================================================================================
+// Definitions for MSG_TYPE_BATTERY
+//============================================================================================
+typedef enum             // commands inside flashstream packets
+{
+    BATT_FSCMD_WRITE_CONTINUED         = 'w',    // I2C write transaction which will be continued in the next packet
+    BATT_FSCMD_WRITE                   = 'W',    // the last or the only packet of I2C write transaction
+    BATT_FSCMD_READ                    = 'R',    // I2C read transaction
+    // I2C read/compare transaction means read then compare the read data with the contents of the packet, mismatch is a hard error
+    BATT_FSCMD_READ_COMPARE_CONTINUED  = 'c',    // I2C read/compare transaction which will be continued in the next packet
+    BATT_FSCMD_READ_COMPARE            = 'C',    // the last or the only packet of I2C read/compare transaction
+    BATT_FSCMD_WAIT                    = 'X',    // wait specified number of ms
+    BATT_FSCMD_END                     = 'E',    // end of flash stream
+
+} FlashStreamCommands;
+
+typedef enum             // flashstream transaction status values
+{
+    BATT_FS_STATUS_SUCCESS = 1,   // all good
+    BATT_FS_STATUS_FAILURE,       // I2C transaction failed
+    BATT_FS_STATUS_MISMATCH,      // read/compare failed
+    BATT_FS_STATUS_SEQ_BREAK,     // received flashstream packet out of sequence
+    BATT_FS_STATUS_TOO_LONG,      // more than 96 bytes of data in a transaction
+
+} FlashStreamStatus;
+
+typedef enum             // values for the BATT_CMD_OVERRIDE_CHARGE_RATE ioctl (1 data byte) and for the "charge_rate" bit field of BATT_CMD_GET_STATUS
+{
+    BATT_CHARGER_NONE = 1,             // no charger (in BATT_CMD_STATUS); do not force charge rate (in BATT_CMD_OVERRIDE_CHARGE_RATE)
+    BATT_CHARGER_100mA,                // there is charger, drawing 100 mA (in BATT_CMD_STATUS); force 100 mA draw (in BATT_CMD_OVERRIDE_CHARGE_RATE)
+    BATT_CHARGER_500mA,                // there is charger, drawing 500 mA (in BATT_CMD_STATUS); force 500 mA draw (in BATT_CMD_OVERRIDE_CHARGE_RATE)
+    BATT_CHARGER_1A,                   // there is charger, drawing 1 A (in BATT_CMD_STATUS); force 1 A draw (in BATT_CMD_OVERRIDE_CHARGE_RATE)
+    BATT_CHARGER_OFF,                  // there is charger, but we are not drawing any current (in BATT_CMD_STATUS); force charger off (in BATT_CMD_OVERRIDE_CHARGE_RATE)
+
+} BattChargerRate;
+
+typedef struct      // BATT_NOTIFY_GG_ERROR format
+{
+    u8   readOrWriteAndReg;  // register we attempted IO on; high bit clear = read, set = write
+    s16  errorCode;          // status_code_t enum
+
+} BattGGErrorCmd;
+
+typedef struct      // BATT_CMD_GET_STATUS format
+{
+    u8   charging : 1;            // 1 = battery is charging, 0 = not charging
+    u8   charge_rate : 3;         // values are from the BattChargerRate enum
+    u8   rate_forced : 1;         // 1 = charge rate is forced by the SOM, 0 = determined internally
+    u8   alpha_battery : 2;      // for alpha only: 1 = reporting the 1st battery, 2 = reporting the 2nd battery
+    u8   too_frequent : 1;        // 1 = last BAT_CMD_STATUS was processed less then .5 sec ago, this response contains no data, 0 = this response contains data
+    u16  voltage;                 // in mV; 0 = last BAT_CMD_GET_STATUS was processed less then .5 sec ago, this response contains no data
+    u16  remainingCapacity;       // in mAh
+    u16  fullCapacity;            // in mAh
+    s16  averageCurrent;          // in mA
+    u16  timeToEmpty;             // in minutes, 0xFFFF == battery is not being discharged
+    u16  timeToFull;              // in minutes, 0xFFFF == battery is not being charged
+    s16  maxCurrent;              // in mA
+    u16  cycleCount;
+
+} BattStatusCmd;
+
+typedef struct      // BATT_CMD_GET_GG_VERSION format
+{
+    u16  deviceType;         // type of the IC
+    u16  fwVersion;          // firmware version
+
+} BattGGVersionCmd;
+
+typedef struct
+{
+    u8   address;            // I2C address
+    u8   reg;                // register number in the gas gauge
+    u8   data[1];            // variable length array of bytes to write
+
+} FSWriteAndReadCompareCmd;
+
+typedef struct
+{
+    u8   address;            // I2C address
+    u8   reg;                // register number in the gas gauge
+    u8   num;                // number of bytes to read
+
+} FSReadCmd;
+
+typedef struct      // BATT_CMD_FS_PKT format
+{
+    u8   size;          // size of this structure, excluding this field itself
+    u16  seq;           // sequence; starts with 1 and increments with each packet
+    u8   cmd;           // what this packet is about; values are from FlashStreamCommands enum
+    union
+    {
+        FSWriteAndReadCompareCmd dataWRC;
+        FSReadCmd                dataR;
+        u16                      waitTime;
+        u8                       contArray[1];  // variable length array of continuation commands
+
+    } cmdData;
+
+} FSPktCmd;
+
+typedef struct      // BATT_CMD_NOTIFY_FS_PKT_STATUS format
+{
+    u16  seq;           // sequence; must match the sequence of the packet to which it is responding
+    u8   status;        // status; values are from FlashStreamStatus enum
+
+} FSPktStatusCmd;
+
+//============================================================================================
+// Definitions for protocol commands (do not involve communications with the MCU)
+//============================================================================================
+typedef struct      // PROT_CMD_GET_STATISTICS1 format
+{
+    u32 rx_timeoutCnt;                      // number of timeouts on reception that have occurred
+    u32 rx_brokenCnt;                       // number of broken messages that have been received
+    u32 rx_successCnt;                      // number of successfully received messages
+    u32 rx_wrongSTXCnt;                     // number of unexpected STX in packets
+    u32 rx_orphanedCnt;                     // number of received bytes not belonging to a packet
+    u32 rx_bugCnt;                          // number of occurrences in the parser that could not have happened
+    u32 rx_resetCnt;                        // number of received reset commands
+    u32 rx_resetFailedCnt;                  // number of failed received reset commands
+    u32 rx_overflowCnt;                     // number of UART overflow errors
+    u32 rx_framingCnt;                      // number of UART framing errors
+    u32 rx_parityCnt;                       // number of UART parity errors
+    u32 rx_wrongSeqCnt;                     // number of wrong sequence numbers in received packets
+
+} ProtStat1Cmd;
+
+typedef struct      // PROT_CMD_GET_STATISTICS2 format
+{
+    u32 rx_longNotCnt;                      // number of notifications too long to be accepted
+    u32 rx_repeatCnt;                       // number of repeated received packets
+    u32 rx_ackCnt;                          // number of received ACK's
+    u32 rx_lostProfileCnt;                  // number of unconsumed current profile packets
+    u32 rx_lostPacketCnt;                   // number of unconsumed non-current profile packets
+    u32 tx_noackCnt;                        // the number of non-acknowledged transmitted packets
+    u32 tx_reXmitCnt;                       // the number of packet re-transmissions
+    u32 tx_resetCnt;                        // number of initiated reset commands
+    u32 tx_resetFailedCnt;                  // number of failed initiated reset commands
+    u32 tx_packetsCnt;                      // number of transmitted packets
+    u32 tx_acksCnt;                         // number of transmitted acks
+    u32 RxTxHardCnt;                        // number of protocol hard errors.
+
+} ProtStat2Cmd;
+
+typedef struct      // PROT_CMD_GET_STATISTICS3 format
+{
+    u32 rx_fifoOverrunCnt;                  // number of ACK FIFO overruns
+    u32 notFifoOverrunCnt;                  // number of notification FIFO overruns
+    u32 tx_timeoutCnt;                      // the number of ioctl timeouts
+    u32 rx_tempBufCnt;                      // number of times extra current profile buffer was used
+} ProtStat3Cmd;
+
+//============================================================================================
+// Definitions for notifications.
+//============================================================================================
+// notifications require a 4-byte output buffer, it will be filled as follows.
+typedef struct
+{
+    u8   type;
+
+    union
+    {
+        u8                       invalidCmd;
+        MotorGotoCompleteCmd     motorMoveResult;
+        BattGGErrorCmd           battGGError;
+        FSPktStatusCmd           fsStatus;
+
+    } data;
+
+} MCU_NotificationInfo;
+
+//============================================================================================
+// Union of all the above passed as ioctl buffer.
+//============================================================================================
+typedef struct
+{
+    union
+    {
+        IndPulseTrainCmd         pulseTrain;
+        IndLEDCmd                rgbLed;
+        IndBuzzerCmd             buzzerFreq;
+        IndPulseTrainDefCmd      trainDefinition;
+
+        SysFirmVerCmd            firmwareVersion;
+        SysStats1Cmd             mcuStats1;
+        SysStats2Cmd             mcuStats2;
+        SysStats3Cmd             mcuStats3;
+        SysStats4Cmd             mcuStats4;
+        SysEpromCmd              epromPage;
+        SysStacksCmd             mcuStacks;
+
+        MotorCurProfile          currentProfile;
+        MotorGotoCmd             motorMove;
+        MotorPWMCmd              motorPower;
+        MotorAllParmsCmd         motorAllParms;
+        MotorProfileArrayCmd     motorProfileArray;
+        MotorAllSensorsCmd       motorAllSensors;
+
+        BattStatusCmd            battStatus;
+        BattGGVersionCmd         battGGVersion;
+        FSPktCmd                 fsPacket;
+
+        ProtStat1Cmd             localStats1;
+        ProtStat2Cmd             localStats2;
+        ProtStat3Cmd             localStats3;
+        char                     driverVersion[DRIVER_VERSION_SIZE];
+
+        MCU_NotificationInfo     notification;
+
+        u8                       val8bits;
+        u16                      val16bits;
+        u32                      val32bits;
+        // maximum possible packet payload excluding command, plus 1 byte size for variable length ioctl's; inclusion of it here guarantees the correct size of this structure
+        u8                       rawPacket[MAX_DATA_LENGTH];
+
+    } data;    // either input or output
+
+} idexxmcu_message_t;
+
+#pragma pack(pop)
+
+// Ioctl
+// This ioctl will receive all notifications from the MCU.  This will typically be called in a separate thread.
+// This function will block until it is woken up by the kernel v with a message dispatched from the MCU
+#define IDEXX_MCU_NOTIFICATION_CMD                     _IOR(IDEXXMCU_PROTO_MAGIC, NOTIFICATION_CMD, idexxmcu_message_t)
+
+// indicator ioctl's
+#define IDEXX_MCU_IND_CMD_PULSE_TRAIN                  _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_LED_SET                      _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_LED_SET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_BUZZER_SET                   _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_BUZZER_SET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_LED_GET                      _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_LED_GET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_BUZZER_GET                   _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_BUZZER_GET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_PULSE_TRAIN_GET              _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN_GET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_PULSE_TRAIN_DEF_GET          _IOR(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN_DEF_GET, idexxmcu_message_t)
+#define IDEXX_MCU_IND_CMD_PULSE_TRAIN_DEF_SET          _IOW(IDEXXMCU_PROTO_MAGIC, IND_CMD_PULSE_TRAIN_DEF_SET, idexxmcu_message_t)
+
+// system ioctl's
+#define IDEXX_MCU_SYS_CMD_SOM_IS_UP                    _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_SOM_IS_UP)
+#define IDEXX_MCU_SYS_CMD_SHUTDOWN                     _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_SHUTDOWN)
+#define IDEXX_MCU_SYS_CMD_GET_FW_VER                   _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_FW_VER, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_GET_STATS1                   _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS1, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_GET_STATS2                   _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS2, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_GET_STATS3                   _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS3, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_GET_STATS4                   _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_GET_STATS4, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_ZAP_STATS                    _IO(IDEXXMCU_PROTO_MAGIC, SYS_CMD_ZAP_STATS)
+#define IDEXX_MCU_SYS_CMD_EPROM_PAGE_GET               _IOWR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_EPROM_PAGE_GET, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_EPROM_PAGE_SET               _IOW(IDEXXMCU_PROTO_MAGIC, SYS_CMD_EPROM_PAGE_SET, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_EPROM_PAGE_ERASE             _IOW(IDEXXMCU_PROTO_MAGIC, SYS_CMD_EPROM_PAGE_ERASE, idexxmcu_message_t)
+#define IDEXX_MCU_SYS_CMD_STACK_SIZES_GET              _IOR(IDEXXMCU_PROTO_MAGIC, SYS_CMD_STACK_SIZES_GET, idexxmcu_message_t)
+
+// motor ioctl's
+// This ioctl is a special case and requires a pointer to a large user space buffer
+// and it will also block until the entire profile is received.  The allocated
+// buffer should be protected from access in the user space.
+#define IDEXX_MCU_MOTOR_CMD_ACCEPT_PROFILE             _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACCEPT_PROFILE, idexxmcu_message_t)
+
+#define IDEXX_MCU_MOTOR_CMD_ADC_OFFSET_GET             _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ADC_OFFSET_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_GOTO                       _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_GOTO, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_GOTO_WITH_PROFILE          _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_GOTO_WITH_PROFILE, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_BRAKE          _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_BRAKE)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_POWEROFF       _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_POWEROFF)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_CCW            _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_CCW)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_CW             _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_CW)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PWM            _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PWM, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE  _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_MOTOR_DISABLE)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE   _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_MOTOR_ENABLE)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PROFILE_OFF    _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PROFILE_OFF)
+#define IDEXX_MCU_MOTOR_CMD_SOM_CONTROL_PROFILE_ON     _IO(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_SOM_CONTROL_PROFILE_ON)
+#define IDEXX_MCU_MOTOR_CMD_STALL_CURRENT_GET          _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_STALL_CURRENT_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_STALL_CURRENT_SET          _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_STALL_CURRENT_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ALL_PARMS_GET              _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ALL_PARMS_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ALL_PARMS_SET              _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ALL_PARMS_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_STALL_SAMPLES_GET          _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_STALL_SAMPLES_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_STALL_SAMPLES_SET          _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_STALL_SAMPLES_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_NO_STALL_CURRENT_GET       _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_NO_STALL_CURRENT_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_NO_STALL_CURRENT_SET       _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_NO_STALL_CURRENT_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_NO_STALL_SAMPLES_GET       _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_NO_STALL_SAMPLES_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_NO_STALL_SAMPLES_SET       _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_NO_STALL_SAMPLES_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_SNAP_GET           _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_SNAP_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_SNAP_SET           _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_SNAP_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_HOME_GET           _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_HOME_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_HOME_SET           _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_HOME_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_UP_GET             _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_UP_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_UP_SET             _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_UP_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_DOWN_GET           _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_DOWN_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_TIMEOUT_DOWN_SET           _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_TIMEOUT_DOWN_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_MAX_PWM_GET                _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_MAX_PWM_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_MAX_PWM_SET                _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_MAX_PWM_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_FREQ_GET                   _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_FREQ_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_FREQ_SET                   _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_FREQ_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ACC_PROF_GET               _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACC_PROF_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ACC_PROF_SET               _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACC_PROF_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ACC_STEP_GET               _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACC_STEP_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ACC_STEP_SET               _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ACC_STEP_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_DEC_PROF_GET               _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_DEC_PROF_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_DEC_PROF_SET               _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_DEC_PROF_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_DEC_STEP_GET               _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_DEC_STEP_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_DEC_STEP_SET               _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_DEC_STEP_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_UP_DIR_GET                 _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_UP_DIR_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_UP_DIR_SET                 _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_UP_DIR_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_PROFILE_ARRAY_GET          _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_PROFILE_ARRAY_GET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_PROFILE_ARRAY_SET          _IOW(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_PROFILE_ARRAY_SET, idexxmcu_message_t)
+#define IDEXX_MCU_MOTOR_CMD_ALL_SENSORS_GET            _IOR(IDEXXMCU_PROTO_MAGIC, MOTOR_CMD_ALL_SENSORS_GET, idexxmcu_message_t)
+
+// battery ioctl's
+#define IDEXX_MCU_BATT_CMD_GET_STATUS                  _IOR(IDEXXMCU_PROTO_MAGIC, BATT_CMD_GET_STATUS, idexxmcu_message_t)
+#define IDEXX_MCU_BATT_CMD_GET_GG_VERSION              _IOR(IDEXXMCU_PROTO_MAGIC, BATT_CMD_GET_GG_VERSION, idexxmcu_message_t)
+#define IDEXX_MCU_BATT_CMD_FS_PKT                      _IOW(IDEXXMCU_PROTO_MAGIC, BATT_CMD_FS_PKT, idexxmcu_message_t)
+#define IDEXX_MCU_BATT_CMD_OVERRIDE_CHARGE_RATE        _IOW(IDEXXMCU_PROTO_MAGIC, BATT_CMD_OVERRIDE_CHARGE_RATE, idexxmcu_message_t)
+
+// protocol ioctl's
+#define IDEXX_MCU_PROT_CMD_GET_STATISTICS1             _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS1, idexxmcu_message_t)
+#define IDEXX_MCU_PROT_CMD_GET_STATISTICS2             _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS2, idexxmcu_message_t)
+#define IDEXX_MCU_PROT_CMD_GET_STATISTICS3             _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_STATISTICS3, idexxmcu_message_t)
+#define IDEXX_MCU_PROT_CMD_ZAP_STATISTICS              _IO(IDEXXMCU_PROTO_MAGIC, PROT_CMD_ZAP_STATISTICS)
+#define IDEXX_MCU_PROT_CMD_GET_DRIVER_VERSION          _IOR(IDEXXMCU_PROTO_MAGIC, PROT_CMD_GET_DRIVER_VERSION, idexxmcu_message_t)
+
+#endif    // SOM_MCU_IOCTL_DESC_H
diff --git a/include/media/v4l2-chip-ident.h b/include/media/v4l2-chip-ident.h
index 214b4c7..4352eaa 100644
--- a/include/media/v4l2-chip-ident.h
+++ b/include/media/v4l2-chip-ident.h
@@ -78,6 +78,7 @@ enum {
 	V4L2_IDENT_OV9740 = 260,
 	V4L2_IDENT_OV5642 = 261,
 	V4L2_IDENT_OV3640 = 262,
+	V4L2_IDENT_OV5640 = 263,
 
 
 	/* module saa7146: reserved range 300-309 */
-- 
1.7.9.5

